import asdl
import os


class ASDLVisitor(asdl.VisitorBase): 

    def __init__(self, stream):
        super(ASDLVisitor, self).__init__()
        self.stream = stream

    def visitModule(self, mod, *args):
        for df in mod.dfns:
            self.visit(df, *args)

    def visitSum(self, sum, *args):
        for tp in sum.types:
            self.visit(tp, *args)

    def visitType(self, tp, *args):
        self.visit(tp.value, *args)

    def visitProduct(self, prod, *args):
        for field in prod.fields:
            self.visit(field, *args)

    def visitConstructor(self, cons, *args):
        for field in cons.fields:
            self.visit(field, *args)

    def visitField(self, field, *args):
        pass

    def emit(self, line, level=0):
        indent = "    "*level
        self.stream.write(indent + line + "\n")


def is_simple_sum(sum):
    assert isinstance(sum, asdl.Sum)
    for constructor in sum.types:
        if constructor.fields:
            return False
    return True


class ASTNodeVisitor(ASDLVisitor):

    def visitType(self, tp):
        self.visit(tp.value, tp.name)

    def visitSum(self, sum, base):
        if is_simple_sum(sum):
            self.emit(f"class {base} {'{'}")
            for i, cons in enumerate(sum.types):
                self.emit(f"class _{cons.name} extends {base} {'{'}")
                self.emit("}")
                self.emit("")
            for i, cons in enumerate(sum.types):
                self.emit("%s = %i" % (cons.name, i + 1))
            self.emit("")
            self.emit("%s_to_class = [" % (base,))
            for cons in sum.types:
                self.emit("_%s," % (cons.name,), 1)
            self.emit("]")
            self.emit("")
        else:
            self.emit(f"class {base} {'{'}")
            if sum.attributes:
                self.emit("")
                args = ", ".join(attr.name for attr in sum.attributes)
                self.emit(f"constructor ({args}) {'{'}", 1)
                for attr in sum.attributes:
                    self.visit(attr)
                self.emit("}", 1)
                self.emit("}")
                self.emit("")

            for cons in sum.types:
                self.visit(cons, base, sum.attributes)
                self.emit("")


    def visitProduct(self, product, name):
        self.emit(f"class {name} extends AST {'{'}")
    
    def visitField(self, field, *args):
        self.emit(f"this.{field.name} = {field.name};", 2)


class TypeDefVisitor(ASDLVisitor):
    def visitModule(self, mod):
        for dfn in mod.dfns:
            self.visit(dfn)

    def visitType(self, type, depth=0):
        self.visit(type.value, type.name, depth)

    def visitSum(self, sum, name, depth):
        if is_simple_sum(sum):
            self.simple_sum(sum, name, depth)

    def simple_sum(self, sum, name, depth):
        self.emit("/* ----- %s ----- */" % name, depth)
        for i in range(len(sum.types)):
            self.emit("/** @constructor */", depth)
            type = sum.types[i]
            self.emit(f"export class {type.name} {{}}", depth)
        self.emit("", depth)

    def visitProduct(self, product, name, depth):
        pass

class FunctionVisitor(PrototypeVisitor):
    """Visitor to generate constructor functions for AST."""

    def emit_function(self, name, ctype, args, attrs, union=1):
        def emit(s, depth=0, reflow=1):
            self.emit(s, depth, reflow)
        argstr = ", ".join(["/* {%s} */ %s" % (atype, aname)
                            for atype, aname, opt in args + attrs])
        emit("/** @constructor */")
        emit("Sk.astnodes.%s = function %s(%s)" % (name, name, argstr))
        emit("{")
        for argtype, argname, opt in attrs:
            if not opt:
                emit("Sk.asserts.assert(%s !== null && %s !== undefined);" % (argname, argname), 1)

        if union:
            self.emit_body_union(name, args, attrs)
        else:
            self.emit_body_struct(name, args, attrs)
        emit("return this;", 1)
        emit("}")
        emit("")


class ChainOfVisitors:
    def __init__(self, *visitors):
        self.visitors = visitors

    def visit(self, object):
        for v in self.visitors:
            v.visit(object)
            v.emit("", 0)


common_msg = "/* File automatically generated by %s. */\n\n"

def main(asdlfile, outputfile):
    argv0 = sys.argv[0]
    components = argv0.split(os.sep)
    argv0 = os.sep.join(components[-2:])
    auto_gen_msg = common_msg % argv0
    mod = asdl.parse(asdlfile)
    if not asdl.check(mod):
        sys.exit(1)

    f = open(outputfile, "w")

    f.write(auto_gen_msg)
    f.write("/* Object that holds all nodes */\n");
    
    c = ChainOfVisitors(TypeDefVisitor(f),
    ASTNodeVisitor(f)
                        )
    c.visit(mod)

    f.write("\n"*5)
    f.write("/* ---------------------- */\n")
    f.write("/* constructors for nodes */\n")
    f.write("/* ---------------------- */\n")
    f.write("\n"*5)
    # v = ChainOfVisitors(
    #     FunctionVisitor(f),
    #     FieldNamesVisitor(f),
    #     )
    # v.visit(mod)

    f.close()

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 3:
        print("usage: asdl_js.py input.asdl output.js")
        raise SystemExit()
    main(sys.argv[1], sys.argv[2])
