var Sk = (function (exports) {
    'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    /* File automatically generated by asdl_js.py. */

    /* Object that holds all nodes */
    /* ----- expr_context ----- */
    /** @constructor */
    const Load = function Load() {};
    /** @constructor */
    const Store = function Store() {};
    /** @constructor */
    const Del = function Del() {};

    /* ----- boolop ----- */
    /** @constructor */
    const And = function And() {};
    /** @constructor */
    const Or = function Or() {};

    /* ----- operator ----- */
    /** @constructor */
    const Add = function Add() {};
    /** @constructor */
    const Sub = function Sub() {};
    /** @constructor */
    const Mult = function Mult() {};
    /** @constructor */
    const MatMult = function MatMult() {};
    /** @constructor */
    const Div = function Div() {};
    /** @constructor */
    const Mod = function Mod() {};
    /** @constructor */
    const Pow = function Pow() {};
    /** @constructor */
    const LShift = function LShift() {};
    /** @constructor */
    const RShift = function RShift() {};
    /** @constructor */
    const BitOr = function BitOr() {};
    /** @constructor */
    const BitXor = function BitXor() {};
    /** @constructor */
    const BitAnd = function BitAnd() {};
    /** @constructor */
    const FloorDiv = function FloorDiv() {};

    /* ----- unaryop ----- */
    /** @constructor */
    const Invert = function Invert() {};
    /** @constructor */
    const Not = function Not() {};
    /** @constructor */
    const UAdd = function UAdd() {};
    /** @constructor */
    const USub = function USub() {};

    /* ----- cmpop ----- */
    /** @constructor */
    const Eq = function Eq() {};
    /** @constructor */
    const NotEq = function NotEq() {};
    /** @constructor */
    const Lt = function Lt() {};
    /** @constructor */
    const LtE = function LtE() {};
    /** @constructor */
    const Gt = function Gt() {};
    /** @constructor */
    const GtE = function GtE() {};
    /** @constructor */
    const Is = function Is() {};
    /** @constructor */
    const IsNot = function IsNot() {};
    /** @constructor */
    const In = function In() {};
    /** @constructor */
    const NotIn = function NotIn() {};

    /** @constructor */
    const Interactive = function Interactive(/* {asdl_seq *} */ body) {
      this.body = body;
    };

    /** @constructor */
    const Expression = function Expression(/* {expr_ty} */ body) {
      this.body = body;
    };

    class FunctionType {}

    /** @constructor */
    const FunctionDef = function FunctionDef(
      /* {identifier} */ name,
      /*
                                                        {arguments__ty} */ args,
      /*
                                                        {asdl_seq *} */ body /*
                                                        {asdl_seq *} */,
      decorator_list,
      /*
                                                        {expr_ty} */ returns,
      /*
                                                        {string} */ docstring,
      /*
                                                        {int} */ lineno,
      /* {int}
       */ col_offset
    ) {
      this.name = name;
      this.args = args;
      this.body = body;
      this.decorator_list = decorator_list;
      this.returns = returns;
      this.docstring = docstring;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const AsyncFunctionDef = function AsyncFunctionDef /* {identifier} */(
      name,
      /*
                                                                  {arguments__ty}
                                                                  */ args /*
                                                                  {asdl_seq *} */,
      body /*
                                                                  {asdl_seq *} */,
      decorator_list,
      /* {expr_ty} */
      returns /*
                                                                  {string} */,
      docstring,
      /*
                                                                  {int} */ lineno,
      /* {int} */
      col_offset
    ) {
      this.name = name;
      this.args = args;
      this.body = body;
      this.decorator_list = decorator_list;
      this.returns = returns;
      this.docstring = docstring;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const ClassDef = function ClassDef(
      /* {identifier} */ name,
      /* {asdl_seq
       *} */ bases /* {asdl_seq *} */,
      keywords /* {asdl_seq *} */,
      body /* {asdl_seq *} */,
      decorator_list /* {string} */,
      docstring,
      /* {int} */ lineno,
      /*
                                                  {int} */ col_offset
    ) {
      this.name = name;
      this.bases = bases;
      this.keywords = keywords;
      this.body = body;
      this.decorator_list = decorator_list;
      this.docstring = docstring;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Return = function Return(
      /* {expr_ty} */ value,
      /* {int} */ lineno,
      /* {int} */ col_offset
    ) {
      this.value = value;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Delete = function Delete(
      /* {asdl_seq *} */ targets /* {int} */,
      lineno,
      /* {int} */ col_offset
    ) {
      this.targets = targets;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Assign = function Assign(
      /* {asdl_seq *} */ targets,
      /* {expr_ty}
       */ value,
      /* {int} */ lineno,
      /*
                                              {int} */ col_offset
    ) {
      this.targets = targets;
      this.value = value;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const AugAssign = function AugAssign(
      /* {expr_ty} */ target,
      /*
                                                    {operator_ty} */ op,
      /*
                                                    {expr_ty} */ value /* {int} */,
      lineno,
      /* {int} */ col_offset
    ) {
      this.target = target;
      this.op = op;
      this.value = value;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    class AugOperator {}

    /** @constructor */
    const AnnAssign = function AnnAssign(
      /* {expr_ty} */ target,
      /* {expr_ty}
       */ annotation /* {expr_ty} */,
      value,
      /* {int} */ simple,
      /*
                                                    {int} */ lineno /* {int} */,
      col_offset
    ) {
      this.target = target;
      this.annotation = annotation;
      this.value = value;
      this.simple = simple;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const For = function For(
      /* {expr_ty} */ target,
      /* {expr_ty} */ iter,
      /*
                                        {asdl_seq *} */ body /* {asdl_seq *} */,
      orelse,
      /* {int} */ lineno /* {int} */,
      col_offset
    ) {
      this.target = target;
      this.iter = iter;
      this.body = body;
      this.orelse = orelse;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const AsyncFor = function AsyncFor(
      /* {expr_ty} */ target,
      /* {expr_ty}
       */ iter,
      /* {asdl_seq *} */ body,
      /* {asdl_seq *} */ orelse,
      /*
                                                  {int} */ lineno /* {int} */,
      col_offset
    ) {
      this.target = target;
      this.iter = iter;
      this.body = body;
      this.orelse = orelse;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const While = function While(
      /* {expr_ty} */ test /* {asdl_seq *} */,
      body,
      /* {asdl_seq *} */ orelse,
      /*
                                            {int} */ lineno,
      /* {int} */ col_offset
    ) {
      this.test = test;
      this.body = body;
      this.orelse = orelse;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const If = function If(
      /* {expr_ty} */ test,
      /* {asdl_seq *} */ body,
      /*
                                      {asdl_seq *} */ orelse,
      /* {int} */ lineno,
      /* {int} */ col_offset
    ) {
      this.test = test;
      this.body = body;
      this.orelse = orelse;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const With = function With(
      /* {asdl_seq *} */ items /* {asdl_seq *} */,
      body,
      /* {int} */ lineno /* {int} */,
      col_offset
    ) {
      this.items = items;
      this.body = body;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const AsyncWith = function AsyncWith(
      /* {asdl_seq *} */ items,
      /*
                                                    {asdl_seq *} */ body,
      /* {int}
       */ lineno /* {int} */,
      col_offset
    ) {
      this.items = items;
      this.body = body;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Raise = function Raise(
      /* {expr_ty} */ exc,
      /* {expr_ty} */ cause,
      /* {expr_ty} */ inst /* {expr_ty} */,
      tback,
      /* {int} */ lineno /* {int} */,
      col_offset
    ) {
      this.exc = exc;
      this.cause = cause;
      this.inst = inst;
      this.tback = tback;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Try = function Try(
      /* {asdl_seq *} */ body /* {asdl_seq *} */,
      handlers,
      /* {asdl_seq *} */ orelse,
      /*
                                        {asdl_seq *} */ finalbody /* {int} */,
      lineno,
      /* {int} */ col_offset
    ) {
      this.body = body;
      this.handlers = handlers;
      this.orelse = orelse;
      this.finalbody = finalbody;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Assert = function Assert(
      /* {expr_ty} */ test,
      /* {expr_ty} */ msg,
      /* {int} */ lineno /* {int} */,
      col_offset
    ) {
      this.test = test;
      this.msg = msg;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Import = function Import(
      /* {asdl_seq *} */ names /* {int} */,
      lineno,
      /* {int} */ col_offset
    ) {
      this.names = names;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const ImportFrom = function ImportFrom(
      /* {identifier} */ module,
      /*
                                                      {asdl_seq *} */ names,
      /*
                                                      {int} */ level /* {int} */,
      lineno /* {int} */,
      col_offset
    ) {
      this.module = module;
      this.names = names;
      this.level = level;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Global = function Global(
      /* {asdl_seq *} */ names /* {int} */,
      lineno,
      /* {int} */ col_offset
    ) {
      this.names = names;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Nonlocal = function Nonlocal(
      /* {asdl_seq *} */ names /* {int} */,
      lineno,
      /* {int} */ col_offset
    ) {
      this.names = names;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Expr = function Expr(
      /* {expr_ty} */ value,
      /* {int} */ lineno,
      /*
                                          {int} */ col_offset
    ) {
      this.value = value;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Pass = function Pass(/* {int} */ lineno, /* {int} */ col_offset) {
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Break = function Break(
      /* {int} */ lineno,
      /* {int} */ col_offset
    ) {
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Continue = function Continue(
      /* {int} */ lineno /* {int} */,
      col_offset
    ) {
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const BoolOp = function BoolOp(
      /* {boolop_ty} */ op /* {asdl_seq *} */,
      values,
      /* {int} */ lineno,
      /* {int}
       */ col_offset
    ) {
      this.op = op;
      this.values = values;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const BinOp = function BinOp(
      /* {expr_ty} */ left /* {operator_ty} */,
      op,
      /* {expr_ty} */ right /* {int} */,
      lineno,
      /* {int} */ col_offset
    ) {
      this.left = left;
      this.op = op;
      this.right = right;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const UnaryOp = function UnaryOp(
      /* {unaryop_ty} */ op /* {expr_ty} */,
      operand,
      /* {int} */ lineno,
      /*
                                                {int} */ col_offset
    ) {
      this.op = op;
      this.operand = operand;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Lambda = function Lambda(
      /* {arguments__ty} */ args,
      /* {expr_ty}
       */ body,
      /* {int} */ lineno,
      /* {int}
       */ col_offset
    ) {
      this.args = args;
      this.body = body;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const IfExp = function IfExp(
      /* {expr_ty} */ test,
      /* {expr_ty} */ body,
      /* {expr_ty} */ orelse /* {int} */,
      lineno,
      /* {int} */ col_offset
    ) {
      this.test = test;
      this.body = body;
      this.orelse = orelse;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Dict = function Dict(
      /* {asdl_seq *} */ keys /* {asdl_seq *} */,
      values,
      /* {int} */ lineno /* {int} */,
      col_offset
    ) {
      this.keys = keys;
      this.values = values;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Set$1 = function Set(
      /* {asdl_seq *} */ elts,
      /* {int} */ lineno,
      /*
                                        {int} */ col_offset
    ) {
      this.elts = elts;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const ListComp = function ListComp(
      /* {expr_ty} */ elt,
      /* {asdl_seq *}
       */ generators /* {int} */,
      lineno,
      /* {int} */ col_offset
    ) {
      this.elt = elt;
      this.generators = generators;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const SetComp = function SetComp(
      /* {expr_ty} */ elt /* {asdl_seq *} */,
      generators,
      /* {int} */ lineno,
      /*
                                                {int} */ col_offset
    ) {
      this.elt = elt;
      this.generators = generators;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const DictComp = function DictComp(
      /* {expr_ty} */ key /* {expr_ty} */,
      value /* {asdl_seq *} */,
      generators,
      /* {int} */ lineno,
      /* {int} */ col_offset
    ) {
      this.key = key;
      this.value = value;
      this.generators = generators;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const GeneratorExp = function GeneratorExp(
      /* {expr_ty} */ elt /*
                                                          {asdl_seq *} */,
      generators /* {int} */,
      lineno /* {int} */,
      col_offset
    ) {
      this.elt = elt;
      this.generators = generators;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Await = function Await(
      /* {expr_ty} */ value,
      /* {int} */ lineno,
      /* {int} */ col_offset
    ) {
      this.value = value;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Yield = function Yield(
      /* {expr_ty} */ value,
      /* {int} */ lineno,
      /* {int} */ col_offset
    ) {
      this.value = value;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const YieldFrom = function YieldFrom(
      /* {expr_ty} */ value /* {int} */,
      lineno,
      /* {int} */ col_offset
    ) {
      this.value = value;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Compare = function Compare(
      /* {expr_ty} */ left,
      /* {asdl_int_seq
       *} */ ops /* {asdl_seq *} */,
      comparators,
      /* {int} */ lineno,
      /*
                                                {int} */ col_offset
    ) {
      this.left = left;
      this.ops = ops;
      this.comparators = comparators;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Call = function Call(
      /* {expr_ty} */ func,
      /* {asdl_seq *} */ args,
      /* {asdl_seq *} */ keywords /* {int} */,
      lineno,
      /* {int} */ col_offset
    ) {
      this.func = func;
      this.args = args;
      this.keywords = keywords;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    const NamedExpr = function NamedExpr() {};

    /** @constructor */
    const Constant = function Constant(
      /* {constant} */ value /* {int} */,
      lineno,
      /* {int} */ col_offset
    ) {
      this.value = value;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Attribute = function Attribute(
      /* {expr_ty} */ value,
      /*
                                                    {identifier} */ attr,
      /*
                                                    {expr_context_ty} */ ctx,
      /*
                                                    {int} */ lineno /* {int} */,
      col_offset
    ) {
      this.value = value;
      this.attr = attr;
      this.ctx = ctx;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Subscript = function Subscript(
      /* {expr_ty} */ value,
      /* {slice_ty}
       */ slice,
      /* {expr_context_ty}
       */ ctx,
      /* {int} */ lineno,
      /*
                                                    {int} */ col_offset
    ) {
      this.value = value;
      this.slice = slice;
      this.ctx = ctx;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Starred = function Starred(
      /* {expr_ty} */ value,
      /*
                                                {expr_context_ty} */ ctx,
      /* {int}
       */ lineno,
      /* {int} */ col_offset
    ) {
      this.value = value;
      this.ctx = ctx;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const List = function List(
      /* {asdl_seq *} */ elts,
      /* {expr_context_ty}
       */ ctx,
      /* {int} */ lineno /* {int} */,
      col_offset
    ) {
      this.elts = elts;
      this.ctx = ctx;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Tuple = function Tuple(
      /* {asdl_seq *} */ elts,
      /*
                                            {expr_context_ty} */ ctx /* {int} */,
      lineno,
      /* {int} */ col_offset
    ) {
      this.elts = elts;
      this.ctx = ctx;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const Slice = function Slice(
      /* {expr_ty} */ lower /* {expr_ty} */,
      upper,
      /* {expr_ty} */ step
    ) {
      this.lower = lower;
      this.upper = upper;
      this.step = step;
    };

    /** @constructor */
    const comprehension = function comprehension(
      /* {expr_ty} */ target,
      /*
                                                            {expr_ty} */ iter,
      /*
                                                            {asdl_seq *} */ ifs,
      /*
                                                            {int} */ is_async
    ) {
      this.target = target;
      this.iter = iter;
      this.ifs = ifs;
      this.is_async = is_async;
    };

    /** @constructor */
    const ExceptHandler = function ExceptHandler(
      /* {expr_ty} */ type,
      /*
                                                            {identifier} */ name,
      /* {asdl_seq *} */
      body /* {int} */,
      lineno /* {int} */,
      col_offset
    ) {
      this.type = type;
      this.name = name;
      this.body = body;
      this.lineno = lineno;
      this.col_offset = col_offset;
    };

    /** @constructor */
    const arg = function arg(
      /* {identifier} */ arg /* {expr_ty} */,
      annotation
    ) {
      this.arg = arg;
      this.annotation = annotation;
    };

    /** @constructor */
    const keyword = function keyword(
      /* {identifier} */ arg /* {expr_ty} */,
      value
    ) {
      this.arg = arg;
      this.value = value;
    };

    /** @constructor */
    const alias = function alias(
      /* {identifier} */ name /* {identifier} */,
      asname
    ) {
      this.name = name;
      this.asname = asname;
    };

    /** @constructor */
    const withitem = function withitem(
      /* {expr_ty} */ context_expr,
      /*
                                                  {expr_ty} */ optional_vars
    ) {
      this.context_expr = context_expr;
      this.optional_vars = optional_vars;
    };

    const ENDMARKER = 0;
    const NAME = 1;
    const NUMBER = 2;
    const STRING = 3;
    const NEWLINE = 4;
    const INDENT = 5;
    const DEDENT = 6;
    const LPAR = 7;
    const RPAR = 8;
    const LSQB = 9;
    const RSQB = 10;
    const COLON = 11;
    const COMMA = 12;
    const SEMI = 13;
    const PLUS = 14;
    const MINUS = 15;
    const STAR = 16;
    const SLASH = 17;
    const VBAR = 18;
    const AMPER = 19;
    const LESS = 20;
    const GREATER = 21;
    const EQUAL = 22;
    const DOT = 23;
    const PERCENT = 24;
    const LBRACE = 25;
    const RBRACE = 26;
    const EQEQUAL = 27;
    const NOTEQUAL = 28;
    const LESSEQUAL = 29;
    const GREATEREQUAL = 30;
    const TILDE = 31;
    const CIRCUMFLEX = 32;
    const LEFTSHIFT = 33;
    const RIGHTSHIFT = 34;
    const DOUBLESTAR = 35;
    const PLUSEQUAL = 36;
    const MINEQUAL = 37;
    const STAREQUAL = 38;
    const SLASHEQUAL = 39;
    const PERCENTEQUAL = 40;
    const AMPEREQUAL = 41;
    const VBAREQUAL = 42;
    const CIRCUMFLEXEQUAL = 43;
    const LEFTSHIFTEQUAL = 44;
    const RIGHTSHIFTEQUAL = 45;
    const DOUBLESTAREQUAL = 46;
    const DOUBLESLASH = 47;
    const DOUBLESLASHEQUAL = 48;
    const AT = 49;
    const ATEQUAL = 50;
    const RARROW = 51;
    const ELLIPSIS = 52;
    const COLONEQUAL = 53;
    const OP = 54;
    const AWAIT = 55;
    const ASYNC = 56;
    const TYPE_IGNORE = 57;
    const TYPE_COMMENT = 58;
    // # These aren't used by the C tokenizer but are needed for tokenize.py
    const ERRORTOKEN = 59;
    const COMMENT = 60;
    const NL = 61;
    const ENCODING = 62;
    const N_TOKENS = 63;
    // # Special definitions for cooperation with parser
    const NT_OFFSET = 256;
    const tokens = {
        ENDMARKER,
        NAME,
        NUMBER,
        STRING,
        NEWLINE,
        INDENT,
        DEDENT,
        LPAR,
        RPAR,
        LSQB,
        RSQB,
        COLON,
        COMMA,
        SEMI,
        PLUS,
        MINUS,
        STAR,
        SLASH,
        VBAR,
        AMPER,
        LESS,
        GREATER,
        EQUAL,
        DOT,
        PERCENT,
        LBRACE,
        RBRACE,
        EQEQUAL,
        NOTEQUAL,
        LESSEQUAL,
        GREATEREQUAL,
        TILDE,
        CIRCUMFLEX,
        LEFTSHIFT,
        RIGHTSHIFT,
        DOUBLESTAR,
        PLUSEQUAL,
        MINEQUAL,
        STAREQUAL,
        SLASHEQUAL,
        PERCENTEQUAL,
        AMPEREQUAL,
        VBAREQUAL,
        CIRCUMFLEXEQUAL,
        LEFTSHIFTEQUAL,
        RIGHTSHIFTEQUAL,
        DOUBLESTAREQUAL,
        DOUBLESLASH,
        DOUBLESLASHEQUAL,
        AT,
        ATEQUAL,
        RARROW,
        ELLIPSIS,
        COLONEQUAL,
        OP,
        AWAIT,
        ASYNC,
        TYPE_IGNORE,
        TYPE_COMMENT,
        // # These aren't used by the C tokenizer but are needed for tokenize.py
        ERRORTOKEN,
        COMMENT,
        NL,
        ENCODING,
        N_TOKENS,
        // # Special definitions for cooperation with parser
        NT_OFFSET,
    };
    Object.freeze(tokens);
    const tok_name = Object.fromEntries(Object.entries(tokens).map(([key, val]) => [val, key]));
    const EXACT_TOKEN_TYPES = {
        "!=": NOTEQUAL,
        "%": PERCENT,
        "%=": PERCENTEQUAL,
        "&": AMPER,
        "&=": AMPEREQUAL,
        "(": LPAR,
        ")": RPAR,
        "*": STAR,
        "**": DOUBLESTAR,
        "**=": DOUBLESTAREQUAL,
        "*=": STAREQUAL,
        "+": PLUS,
        "+=": PLUSEQUAL,
        ",": COMMA,
        "-": MINUS,
        "-=": MINEQUAL,
        "->": RARROW,
        ".": DOT,
        "...": ELLIPSIS,
        "/": SLASH,
        "//": DOUBLESLASH,
        "//=": DOUBLESLASHEQUAL,
        "/=": SLASHEQUAL,
        ":": COLON,
        ":=": COLONEQUAL,
        ";": SEMI,
        "<": LESS,
        "<<": LEFTSHIFT,
        "<<=": LEFTSHIFTEQUAL,
        "<=": LESSEQUAL,
        "=": EQUAL,
        "==": EQEQUAL,
        ">": GREATER,
        ">=": GREATEREQUAL,
        ">>": RIGHTSHIFT,
        ">>=": RIGHTSHIFTEQUAL,
        "@": AT,
        "@=": ATEQUAL,
        "[": LSQB,
        "]": RSQB,
        "^": CIRCUMFLEX,
        "^=": CIRCUMFLEXEQUAL,
        "{": LBRACE,
        "|": VBAR,
        "|=": VBAREQUAL,
        "}": RBRACE,
        "~": TILDE,
    };
    function ISTERMINAL(x) {
        return x < NT_OFFSET;
    }
    function ISNONTERMINAL(x) {
        return x >= NT_OFFSET;
    }
    function ISEOF(x) {
        return x == ENDMARKER;
    }

    var tokens$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ENDMARKER: ENDMARKER,
        NAME: NAME,
        NUMBER: NUMBER,
        STRING: STRING,
        NEWLINE: NEWLINE,
        INDENT: INDENT,
        DEDENT: DEDENT,
        LPAR: LPAR,
        RPAR: RPAR,
        LSQB: LSQB,
        RSQB: RSQB,
        COLON: COLON,
        COMMA: COMMA,
        SEMI: SEMI,
        PLUS: PLUS,
        MINUS: MINUS,
        STAR: STAR,
        SLASH: SLASH,
        VBAR: VBAR,
        AMPER: AMPER,
        LESS: LESS,
        GREATER: GREATER,
        EQUAL: EQUAL,
        DOT: DOT,
        PERCENT: PERCENT,
        LBRACE: LBRACE,
        RBRACE: RBRACE,
        EQEQUAL: EQEQUAL,
        NOTEQUAL: NOTEQUAL,
        LESSEQUAL: LESSEQUAL,
        GREATEREQUAL: GREATEREQUAL,
        TILDE: TILDE,
        CIRCUMFLEX: CIRCUMFLEX,
        LEFTSHIFT: LEFTSHIFT,
        RIGHTSHIFT: RIGHTSHIFT,
        DOUBLESTAR: DOUBLESTAR,
        PLUSEQUAL: PLUSEQUAL,
        MINEQUAL: MINEQUAL,
        STAREQUAL: STAREQUAL,
        SLASHEQUAL: SLASHEQUAL,
        PERCENTEQUAL: PERCENTEQUAL,
        AMPEREQUAL: AMPEREQUAL,
        VBAREQUAL: VBAREQUAL,
        CIRCUMFLEXEQUAL: CIRCUMFLEXEQUAL,
        LEFTSHIFTEQUAL: LEFTSHIFTEQUAL,
        RIGHTSHIFTEQUAL: RIGHTSHIFTEQUAL,
        DOUBLESTAREQUAL: DOUBLESTAREQUAL,
        DOUBLESLASH: DOUBLESLASH,
        DOUBLESLASHEQUAL: DOUBLESLASHEQUAL,
        AT: AT,
        ATEQUAL: ATEQUAL,
        RARROW: RARROW,
        ELLIPSIS: ELLIPSIS,
        COLONEQUAL: COLONEQUAL,
        OP: OP,
        AWAIT: AWAIT,
        ASYNC: ASYNC,
        TYPE_IGNORE: TYPE_IGNORE,
        TYPE_COMMENT: TYPE_COMMENT,
        ERRORTOKEN: ERRORTOKEN,
        COMMENT: COMMENT,
        NL: NL,
        ENCODING: ENCODING,
        N_TOKENS: N_TOKENS,
        NT_OFFSET: NT_OFFSET,
        tokens: tokens,
        tok_name: tok_name,
        EXACT_TOKEN_TYPES: EXACT_TOKEN_TYPES,
        ISTERMINAL: ISTERMINAL,
        ISNONTERMINAL: ISNONTERMINAL,
        ISEOF: ISEOF
    });

    const exact_token_types = EXACT_TOKEN_TYPES;
    class Tokenizer {
        constructor(tokengen, verbose = false) {
            this._tokengen = tokengen;
            this._tokens = [];
            this._index = 0;
            this._verbose = verbose;
            if (verbose) {
                this.report(false, false);
            }
        }
        getnext() {
            let cached = true;
            let tok;
            while (this._index === this._tokens.length) {
                tok = this._tokengen.next().value;
                if (tok.type === NL || tok.type === COMMENT) {
                    continue;
                }
                if (tok.type === ERRORTOKEN && tok.string.isSpace()) {
                    continue;
                }
                this._tokens.push(tok);
                cached = false;
            }
            tok = this._tokens[this._index];
            this._index++;
            if (this._verbose) {
                this.report(cached, false);
            }
            return tok;
        }
        peek() {
            while (this._index === this._tokens.length) {
                const tok = this._tokengen.next().value;
                if (tok.type === NL || tok.type === COMMENT) {
                    continue;
                }
                if (tok.type === ERRORTOKEN && tok.string.isSpace()) {
                    continue;
                }
                this._tokens.push(tok);
            }
            return this._tokens[this._index];
        }
        diagnose() {
            if (!this._tokens.length) {
                this.getnext();
            }
            return this._tokens[this._tokens.length - 1];
        }
        mark() {
            return this._index;
        }
        reset(index) {
            if (index === this._index) {
                return null;
            }
            // assert(0 <= index && index <= this._tokens.length);
            const old_index = this._index;
            this._index = index;
            if (this._verbose) {
                this.report(true, index < old_index);
            }
        }
        report(cached, back) {
            // pass
        }
    }
    function readline(text) {
        const textasarray = text.split("\n").map(x => x + "\n");
        let i = 0;
        return () => textasarray[i++];
    }

    /* From:
        http://difnet.com.br/opensource/unicode_hack.js
        It has been significantly modified.
        Modifications are copyright 2014 Makyen and released under the MPL 2.0.
            This Source Code Form is subject to the terms of the Mozilla Public
            License, v. 2.0. If a copy of the MPL was not distributed with this
            file, You can obtain one at http://mozilla.org/MPL/2.0/.
    */
    /*! unicode_hack.js
        Copyright (C) 2010-2012  Marcelo Gibson de Castro Gonçalves. All rights reserved.

        Copying and distribution of this file, with or without modification,
        are permitted in any medium without royalty provided the copyright
        notice and this notice are preserved.  This file is offered as-is,
        without any warranty.
    */
    const Unicode = {
        /* Strings to match Unicode characters in the BMP according to their Unicode category.
           Extracted from Unicode specification, version 5.0.0, source:
           http://unicode.org/versions/Unicode5.0.0/
        */
        /*
            Abbr    Long                Description
            Lu  Uppercase_Letter        an uppercase letter
            Ll  Lowercase_Letter        a lowercase letter
            Lt  Titlecase_Letter        a digraphic character, with first part uppercase
            LC  Cased_Letter            Lu | Ll | Lt
            Lm  Modifier_Letter         a modifier letter
            Lo  Other_Letter            other letters, including syllables and ideographs
            L   Letter                  Lu | Ll | Lt | Lm | Lo
            Mn  Nonspacing_Mark         a nonspacing combining mark (zero advance width)
            Mc  Spacing_Mark            a spacing combining mark (positive advance width)
            Me  Enclosing_Mark          an enclosing combining mark
            M   Mark                    Mn | Mc | Me
            Nd  Decimal_Number          a decimal digit
            Nl  Letter_Number           a letterlike numeric character
            No  Other_Number            a numeric character of other type
            N   Number                  Nd | Nl | No
            Pc  Connector_Punctuation   a connecting punctuation mark, like a tie
            Pd  Dash_Punctuation        a dash or hyphen punctuation mark
            Ps  Open_Punctuation        an opening punctuation mark (of a pair)
            Pe  Close_Punctuation       a closing punctuation mark (of a pair)
            Pi  Initial_Punctuation     an initial quotation mark
            Pf  Final_Punctuation       a final quotation mark
            Po  Other_Punctuation       a punctuation mark of other type
            P   Punctuation             Pc | Pd | Ps | Pe | Pi | Pf | Po
            Sm  Math_Symbol             a symbol of mathematical use
            Sc  Currency_Symbol         a currency sign
            Sk  Modifier_Symbol         a non-letterlike modifier symbol
            So  Other_Symbol            a symbol of other type
            S   Symbol                  Sm | Sc | Sk | So
            Zs  Space_Separator         a space character (of various non-zero widths)
            Zl  Line_Separator          U+2028 LINE SEPARATOR only
            Zp  Paragraph_Separator     U+2029 PARAGRAPH SEPARATOR only
            Z   Separator               Zs | Zl | Zp
            Cc  Control                 a C0 or C1 control code
            Cf  Format                  a format control character
            Cs  Surrogate               a surrogate code point
            Co  Private_Use             a private-use character
            Cn  Unassigned              a reserved unassigned code point or a noncharacter
            C   Other                   Cc | Cf | Cs | Co | Cn
        */
        /* Alpha Sorted
            Abbr    Long                Description
            C   Other                   Cc | Cf | Cs | Co | Cn
            Cc  Control                 a C0 or C1 control code
            Cf  Format                  a format control character
            Cn  Unassigned              a reserved unassigned code point or a noncharacter
            Co  Private_Use             a private-use character
            Cs  Surrogate               a surrogate code point
            L   Letter                  Lu | Ll | Lt | Lm | Lo
            LC  Cased_Letter            Lu | Ll | Lt
            Ll  Lowercase_Letter        a lowercase letter
            Lm  Modifier_Letter         a modifier letter
            Lo  Other_Letter            other letters, including syllables and ideographs
            Lt  Titlecase_Letter        a digraphic character, with first part uppercase
            Lu  Uppercase_Letter        an uppercase letter
            M   Mark                    Mn | Mc | Me
            Mc  Spacing_Mark            a spacing combining mark (positive advance width)
            Me  Enclosing_Mark          an enclosing combining mark
            Mn  Nonspacing_Mark         a nonspacing combining mark (zero advance width)
            N   Number                  Nd | Nl | No
            Nd  Decimal_Number          a decimal digit
            Nl  Letter_Number           a letterlike numeric character
            No  Other_Number            a numeric character of other type
            P   Punctuation             Pc | Pd | Ps | Pe | Pi | Pf | Po
            Pc  Connector_Punctuation   a connecting punctuation mark, like a tie
            Pd  Dash_Punctuation        a dash or hyphen punctuation mark
            Pe  Close_Punctuation       a closing punctuation mark (of a pair)
            Pf  Final_Punctuation       a final quotation mark
            Pi  Initial_Punctuation     an initial quotation mark
            Po  Other_Punctuation       a punctuation mark of other type
            Ps  Open_Punctuation        an opening punctuation mark (of a pair)
            S   Symbol                  Sm | Sc | Sk | So
            Sc  Currency_Symbol         a currency sign
            Sk  Modifier_Symbol         a non-letterlike modifier symbol
            Sm  Math_Symbol             a symbol of mathematical use
            So  Other_Symbol            a symbol of other type
            Z   Separator               Zs | Zl | Zp
            Zl  Line_Separator          U+2028 LINE SEPARATOR only
            Zp  Paragraph_Separator     U+2029 PARAGRAPH SEPARATOR only
            Zs  Space_Separator         a space character (of various non-zero widths)
        */

        Cc:'\\u0000-\\u001f\\u007f-\\u009f',
        Cf:'\\u00ad\\u0600-\\u0603\\u06dd\\u070f\\u17b4\\u17b5\\u200b-\\u200f\\u202a-\\u202e\\u2060-\\u2063\\u206a-\\u206f\\ufeff\\ufff9-\\ufffb',
        Co:'\\ue000-\\uf8ff',
        Cs:'\\ud800\\udb7f\\udb80\\udbff\\udc00\\udfff',
        Ll:'\\u0061-\\u007a\\u00aa\\u00b5\\u00ba\\u00df-\\u00f6\\u00f8-\\u00ff\\u0101\\u0103\\u0105\\u0107\\u0109\\u010b\\u010d\\u010f\\u0111\\u0113\\u0115\\u0117\\u0119\\u011b\\u011d\\u011f\\u0121\\u0123\\u0125\\u0127\\u0129\\u012b\\u012d\\u012f\\u0131\\u0133\\u0135\\u0137\\u0138\\u013a\\u013c\\u013e\\u0140\\u0142\\u0144\\u0146\\u0148\\u0149\\u014b\\u014d\\u014f\\u0151\\u0153\\u0155\\u0157\\u0159\\u015b\\u015d\\u015f\\u0161\\u0163\\u0165\\u0167\\u0169\\u016b\\u016d\\u016f\\u0171\\u0173\\u0175\\u0177\\u017a\\u017c\\u017e-\\u0180\\u0183\\u0185\\u0188\\u018c\\u018d\\u0192\\u0195\\u0199-\\u019b\\u019e\\u01a1\\u01a3\\u01a5\\u01a8\\u01aa\\u01ab\\u01ad\\u01b0\\u01b4\\u01b6\\u01b9\\u01ba\\u01bd-\\u01bf\\u01c6\\u01c9\\u01cc\\u01ce\\u01d0\\u01d2\\u01d4\\u01d6\\u01d8\\u01da\\u01dc\\u01dd\\u01df\\u01e1\\u01e3\\u01e5\\u01e7\\u01e9\\u01eb\\u01ed\\u01ef\\u01f0\\u01f3\\u01f5\\u01f9\\u01fb\\u01fd\\u01ff\\u0201\\u0203\\u0205\\u0207\\u0209\\u020b\\u020d\\u020f\\u0211\\u0213\\u0215\\u0217\\u0219\\u021b\\u021d\\u021f\\u0221\\u0223\\u0225\\u0227\\u0229\\u022b\\u022d\\u022f\\u0231\\u0233-\\u0239\\u023c\\u023f\\u0240\\u0242\\u0247\\u0249\\u024b\\u024d\\u024f-\\u0293\\u0295-\\u02af\\u037b-\\u037d\\u0390\\u03ac-\\u03ce\\u03d0\\u03d1\\u03d5-\\u03d7\\u03d9\\u03db\\u03dd\\u03df\\u03e1\\u03e3\\u03e5\\u03e7\\u03e9\\u03eb\\u03ed\\u03ef-\\u03f3\\u03f5\\u03f8\\u03fb\\u03fc\\u0430-\\u045f\\u0461\\u0463\\u0465\\u0467\\u0469\\u046b\\u046d\\u046f\\u0471\\u0473\\u0475\\u0477\\u0479\\u047b\\u047d\\u047f\\u0481\\u048b\\u048d\\u048f\\u0491\\u0493\\u0495\\u0497\\u0499\\u049b\\u049d\\u049f\\u04a1\\u04a3\\u04a5\\u04a7\\u04a9\\u04ab\\u04ad\\u04af\\u04b1\\u04b3\\u04b5\\u04b7\\u04b9\\u04bb\\u04bd\\u04bf\\u04c2\\u04c4\\u04c6\\u04c8\\u04ca\\u04cc\\u04ce\\u04cf\\u04d1\\u04d3\\u04d5\\u04d7\\u04d9\\u04db\\u04dd\\u04df\\u04e1\\u04e3\\u04e5\\u04e7\\u04e9\\u04eb\\u04ed\\u04ef\\u04f1\\u04f3\\u04f5\\u04f7\\u04f9\\u04fb\\u04fd\\u04ff\\u0501\\u0503\\u0505\\u0507\\u0509\\u050b\\u050d\\u050f\\u0511\\u0513\\u0561-\\u0587\\u1d00-\\u1d2b\\u1d62-\\u1d77\\u1d79-\\u1d9a\\u1e01\\u1e03\\u1e05\\u1e07\\u1e09\\u1e0b\\u1e0d\\u1e0f\\u1e11\\u1e13\\u1e15\\u1e17\\u1e19\\u1e1b\\u1e1d\\u1e1f\\u1e21\\u1e23\\u1e25\\u1e27\\u1e29\\u1e2b\\u1e2d\\u1e2f\\u1e31\\u1e33\\u1e35\\u1e37\\u1e39\\u1e3b\\u1e3d\\u1e3f\\u1e41\\u1e43\\u1e45\\u1e47\\u1e49\\u1e4b\\u1e4d\\u1e4f\\u1e51\\u1e53\\u1e55\\u1e57\\u1e59\\u1e5b\\u1e5d\\u1e5f\\u1e61\\u1e63\\u1e65\\u1e67\\u1e69\\u1e6b\\u1e6d\\u1e6f\\u1e71\\u1e73\\u1e75\\u1e77\\u1e79\\u1e7b\\u1e7d\\u1e7f\\u1e81\\u1e83\\u1e85\\u1e87\\u1e89\\u1e8b\\u1e8d\\u1e8f\\u1e91\\u1e93\\u1e95-\\u1e9b\\u1ea1\\u1ea3\\u1ea5\\u1ea7\\u1ea9\\u1eab\\u1ead\\u1eaf\\u1eb1\\u1eb3\\u1eb5\\u1eb7\\u1eb9\\u1ebb\\u1ebd\\u1ebf\\u1ec1\\u1ec3\\u1ec5\\u1ec7\\u1ec9\\u1ecb\\u1ecd\\u1ecf\\u1ed1\\u1ed3\\u1ed5\\u1ed7\\u1ed9\\u1edb\\u1edd\\u1edf\\u1ee1\\u1ee3\\u1ee5\\u1ee7\\u1ee9\\u1eeb\\u1eed\\u1eef\\u1ef1\\u1ef3\\u1ef5\\u1ef7\\u1ef9\\u1f00-\\u1f07\\u1f10-\\u1f15\\u1f20-\\u1f27\\u1f30-\\u1f37\\u1f40-\\u1f45\\u1f50-\\u1f57\\u1f60-\\u1f67\\u1f70-\\u1f7d\\u1f80-\\u1f87\\u1f90-\\u1f97\\u1fa0-\\u1fa7\\u1fb0-\\u1fb4\\u1fb6\\u1fb7\\u1fbe\\u1fc2-\\u1fc4\\u1fc6\\u1fc7\\u1fd0-\\u1fd3\\u1fd6\\u1fd7\\u1fe0-\\u1fe7\\u1ff2-\\u1ff4\\u1ff6\\u1ff7\\u2071\\u207f\\u210a\\u210e\\u210f\\u2113\\u212f\\u2134\\u2139\\u213c\\u213d\\u2146-\\u2149\\u214e\\u2184\\u2c30-\\u2c5e\\u2c61\\u2c65\\u2c66\\u2c68\\u2c6a\\u2c6c\\u2c74\\u2c76\\u2c77\\u2c81\\u2c83\\u2c85\\u2c87\\u2c89\\u2c8b\\u2c8d\\u2c8f\\u2c91\\u2c93\\u2c95\\u2c97\\u2c99\\u2c9b\\u2c9d\\u2c9f\\u2ca1\\u2ca3\\u2ca5\\u2ca7\\u2ca9\\u2cab\\u2cad\\u2caf\\u2cb1\\u2cb3\\u2cb5\\u2cb7\\u2cb9\\u2cbb\\u2cbd\\u2cbf\\u2cc1\\u2cc3\\u2cc5\\u2cc7\\u2cc9\\u2ccb\\u2ccd\\u2ccf\\u2cd1\\u2cd3\\u2cd5\\u2cd7\\u2cd9\\u2cdb\\u2cdd\\u2cdf\\u2ce1\\u2ce3\\u2ce4\\u2d00-\\u2d25\\ufb00-\\ufb06\\ufb13-\\ufb17\\uff41-\\uff5a',
        Lm:'\\u02b0-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ee\\u037a\\u0559\\u0640\\u06e5\\u06e6\\u07f4\\u07f5\\u07fa\\u0e46\\u0ec6\\u10fc\\u17d7\\u1843\\u1d2c-\\u1d61\\u1d78\\u1d9b-\\u1dbf\\u2090-\\u2094\\u2d6f\\u3005\\u3031-\\u3035\\u303b\\u309d\\u309e\\u30fc-\\u30fe\\ua015\\ua717-\\ua71a\\uff70\\uff9e\\uff9f',
        Lo:'\\u01bb\\u01c0-\\u01c3\\u0294\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0621-\\u063a\\u0641-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u076d\\u0780-\\u07a5\\u07b1\\u07ca-\\u07ea\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u097b-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d28\\u0d2a-\\u0d39\\u0d60\\u0d61\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e45\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0edc\\u0edd\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6a\\u0f88-\\u0f8b\\u1000-\\u1021\\u1023-\\u1027\\u1029\\u102a\\u1050-\\u1055\\u10d0-\\u10fa\\u1100-\\u1159\\u115f-\\u11a2\\u11a8-\\u11f9\\u1200-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u1676\\u1681-\\u169a\\u16a0-\\u16ea\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17dc\\u1820-\\u1842\\u1844-\\u1877\\u1880-\\u18a8\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19a9\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u2135-\\u2138\\u2d30-\\u2d65\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3006\\u303c\\u3041-\\u3096\\u309f\\u30a1-\\u30fa\\u30ff\\u3105-\\u312c\\u3131-\\u318e\\u31a0-\\u31b7\\u31f0-\\u31ff\\u3400\\u4db5\\u4e00\\u9fbb\\ua000-\\ua014\\ua016-\\ua48c\\ua800\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\uac00\\ud7a3\\uf900-\\ufa2d\\ufa30-\\ufa6a\\ufa70-\\ufad9\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff66-\\uff6f\\uff71-\\uff9d\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc',
        Lt:'\\u01c5\\u01c8\\u01cb\\u01f2\\u1f88-\\u1f8f\\u1f98-\\u1f9f\\u1fa8-\\u1faf\\u1fbc\\u1fcc\\u1ffc',
        Lu:'\\u0041-\\u005a\\u00c0-\\u00d6\\u00d8-\\u00de\\u0100\\u0102\\u0104\\u0106\\u0108\\u010a\\u010c\\u010e\\u0110\\u0112\\u0114\\u0116\\u0118\\u011a\\u011c\\u011e\\u0120\\u0122\\u0124\\u0126\\u0128\\u012a\\u012c\\u012e\\u0130\\u0132\\u0134\\u0136\\u0139\\u013b\\u013d\\u013f\\u0141\\u0143\\u0145\\u0147\\u014a\\u014c\\u014e\\u0150\\u0152\\u0154\\u0156\\u0158\\u015a\\u015c\\u015e\\u0160\\u0162\\u0164\\u0166\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017b\\u017d\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018b\\u018e-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019c\\u019d\\u019f\\u01a0\\u01a2\\u01a4\\u01a6\\u01a7\\u01a9\\u01ac\\u01ae\\u01af\\u01b1-\\u01b3\\u01b5\\u01b7\\u01b8\\u01bc\\u01c4\\u01c7\\u01ca\\u01cd\\u01cf\\u01d1\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u01de\\u01e0\\u01e2\\u01e4\\u01e6\\u01e8\\u01ea\\u01ec\\u01ee\\u01f1\\u01f4\\u01f6-\\u01f8\\u01fa\\u01fc\\u01fe\\u0200\\u0202\\u0204\\u0206\\u0208\\u020a\\u020c\\u020e\\u0210\\u0212\\u0214\\u0216\\u0218\\u021a\\u021c\\u021e\\u0220\\u0222\\u0224\\u0226\\u0228\\u022a\\u022c\\u022e\\u0230\\u0232\\u023a\\u023b\\u023d\\u023e\\u0241\\u0243-\\u0246\\u0248\\u024a\\u024c\\u024e\\u0386\\u0388-\\u038a\\u038c\\u038e\\u038f\\u0391-\\u03a1\\u03a3-\\u03ab\\u03d2-\\u03d4\\u03d8\\u03da\\u03dc\\u03de\\u03e0\\u03e2\\u03e4\\u03e6\\u03e8\\u03ea\\u03ec\\u03ee\\u03f4\\u03f7\\u03f9\\u03fa\\u03fd-\\u042f\\u0460\\u0462\\u0464\\u0466\\u0468\\u046a\\u046c\\u046e\\u0470\\u0472\\u0474\\u0476\\u0478\\u047a\\u047c\\u047e\\u0480\\u048a\\u048c\\u048e\\u0490\\u0492\\u0494\\u0496\\u0498\\u049a\\u049c\\u049e\\u04a0\\u04a2\\u04a4\\u04a6\\u04a8\\u04aa\\u04ac\\u04ae\\u04b0\\u04b2\\u04b4\\u04b6\\u04b8\\u04ba\\u04bc\\u04be\\u04c0\\u04c1\\u04c3\\u04c5\\u04c7\\u04c9\\u04cb\\u04cd\\u04d0\\u04d2\\u04d4\\u04d6\\u04d8\\u04da\\u04dc\\u04de\\u04e0\\u04e2\\u04e4\\u04e6\\u04e8\\u04ea\\u04ec\\u04ee\\u04f0\\u04f2\\u04f4\\u04f6\\u04f8\\u04fa\\u04fc\\u04fe\\u0500\\u0502\\u0504\\u0506\\u0508\\u050a\\u050c\\u050e\\u0510\\u0512\\u0531-\\u0556\\u10a0-\\u10c5\\u1e00\\u1e02\\u1e04\\u1e06\\u1e08\\u1e0a\\u1e0c\\u1e0e\\u1e10\\u1e12\\u1e14\\u1e16\\u1e18\\u1e1a\\u1e1c\\u1e1e\\u1e20\\u1e22\\u1e24\\u1e26\\u1e28\\u1e2a\\u1e2c\\u1e2e\\u1e30\\u1e32\\u1e34\\u1e36\\u1e38\\u1e3a\\u1e3c\\u1e3e\\u1e40\\u1e42\\u1e44\\u1e46\\u1e48\\u1e4a\\u1e4c\\u1e4e\\u1e50\\u1e52\\u1e54\\u1e56\\u1e58\\u1e5a\\u1e5c\\u1e5e\\u1e60\\u1e62\\u1e64\\u1e66\\u1e68\\u1e6a\\u1e6c\\u1e6e\\u1e70\\u1e72\\u1e74\\u1e76\\u1e78\\u1e7a\\u1e7c\\u1e7e\\u1e80\\u1e82\\u1e84\\u1e86\\u1e88\\u1e8a\\u1e8c\\u1e8e\\u1e90\\u1e92\\u1e94\\u1ea0\\u1ea2\\u1ea4\\u1ea6\\u1ea8\\u1eaa\\u1eac\\u1eae\\u1eb0\\u1eb2\\u1eb4\\u1eb6\\u1eb8\\u1eba\\u1ebc\\u1ebe\\u1ec0\\u1ec2\\u1ec4\\u1ec6\\u1ec8\\u1eca\\u1ecc\\u1ece\\u1ed0\\u1ed2\\u1ed4\\u1ed6\\u1ed8\\u1eda\\u1edc\\u1ede\\u1ee0\\u1ee2\\u1ee4\\u1ee6\\u1ee8\\u1eea\\u1eec\\u1eee\\u1ef0\\u1ef2\\u1ef4\\u1ef6\\u1ef8\\u1f08-\\u1f0f\\u1f18-\\u1f1d\\u1f28-\\u1f2f\\u1f38-\\u1f3f\\u1f48-\\u1f4d\\u1f59\\u1f5b\\u1f5d\\u1f5f\\u1f68-\\u1f6f\\u1fb8-\\u1fbb\\u1fc8-\\u1fcb\\u1fd8-\\u1fdb\\u1fe8-\\u1fec\\u1ff8-\\u1ffb\\u2102\\u2107\\u210b-\\u210d\\u2110-\\u2112\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u2130-\\u2133\\u213e\\u213f\\u2145\\u2183\\u2c00-\\u2c2e\\u2c60\\u2c62-\\u2c64\\u2c67\\u2c69\\u2c6b\\u2c75\\u2c80\\u2c82\\u2c84\\u2c86\\u2c88\\u2c8a\\u2c8c\\u2c8e\\u2c90\\u2c92\\u2c94\\u2c96\\u2c98\\u2c9a\\u2c9c\\u2c9e\\u2ca0\\u2ca2\\u2ca4\\u2ca6\\u2ca8\\u2caa\\u2cac\\u2cae\\u2cb0\\u2cb2\\u2cb4\\u2cb6\\u2cb8\\u2cba\\u2cbc\\u2cbe\\u2cc0\\u2cc2\\u2cc4\\u2cc6\\u2cc8\\u2cca\\u2ccc\\u2cce\\u2cd0\\u2cd2\\u2cd4\\u2cd6\\u2cd8\\u2cda\\u2cdc\\u2cde\\u2ce0\\u2ce2\\uff21-\\uff3a',
        Mc:'\\u0903\\u093e-\\u0940\\u0949-\\u094c\\u0982\\u0983\\u09be-\\u09c0\\u09c7\\u09c8\\u09cb\\u09cc\\u09d7\\u0a03\\u0a3e-\\u0a40\\u0a83\\u0abe-\\u0ac0\\u0ac9\\u0acb\\u0acc\\u0b02\\u0b03\\u0b3e\\u0b40\\u0b47\\u0b48\\u0b4b\\u0b4c\\u0b57\\u0bbe\\u0bbf\\u0bc1\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcc\\u0bd7\\u0c01-\\u0c03\\u0c41-\\u0c44\\u0c82\\u0c83\\u0cbe\\u0cc0-\\u0cc4\\u0cc7\\u0cc8\\u0cca\\u0ccb\\u0cd5\\u0cd6\\u0d02\\u0d03\\u0d3e-\\u0d40\\u0d46-\\u0d48\\u0d4a-\\u0d4c\\u0d57\\u0d82\\u0d83\\u0dcf-\\u0dd1\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0f3e\\u0f3f\\u0f7f\\u102c\\u1031\\u1038\\u1056\\u1057\\u17b6\\u17be-\\u17c5\\u17c7\\u17c8\\u1923-\\u1926\\u1929-\\u192b\\u1930\\u1931\\u1933-\\u1938\\u19b0-\\u19c0\\u19c8\\u19c9\\u1a19-\\u1a1b\\u1b04\\u1b35\\u1b3b\\u1b3d-\\u1b41\\u1b43\\u1b44\\ua802\\ua823\\ua824\\ua827',
        Me:'\\u0488\\u0489\\u06de\\u20dd-\\u20e0\\u20e2-\\u20e4',
        Mn:'\\u0300-\\u036f\\u0483-\\u0486\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u0615\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0901\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0954\\u0962\\u0963\\u0981\\u09bc\\u09c1-\\u09c4\\u09cd\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a70\\u0a71\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3f\\u0b41-\\u0b43\\u0b4d\\u0b56\\u0b82\\u0bc0\\u0bcd\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0cbc\\u0cbf\\u0cc6\\u0ccc\\u0ccd\\u0ce2\\u0ce3\\u0d41-\\u0d43\\u0d4d\\u0dca\\u0dd2-\\u0dd4\\u0dd6\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032\\u1036\\u1037\\u1039\\u1058\\u1059\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1dc0-\\u1dca\\u1dfe\\u1dff\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20ef\\u302a-\\u302f\\u3099\\u309a\\ua806\\ua80b\\ua825\\ua826\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe23',
        Nd:'\\u0030-\\u0039\\u0660-\\u0669\\u06f0-\\u06f9\\u07c0-\\u07c9\\u0966-\\u096f\\u09e6-\\u09ef\\u0a66-\\u0a6f\\u0ae6-\\u0aef\\u0b66-\\u0b6f\\u0be6-\\u0bef\\u0c66-\\u0c6f\\u0ce6-\\u0cef\\u0d66-\\u0d6f\\u0e50-\\u0e59\\u0ed0-\\u0ed9\\u0f20-\\u0f29\\u1040-\\u1049\\u17e0-\\u17e9\\u1810-\\u1819\\u1946-\\u194f\\u19d0-\\u19d9\\u1b50-\\u1b59\\uff10-\\uff19',
        Nl:'\\u16ee-\\u16f0\\u2160-\\u2182\\u3007\\u3021-\\u3029\\u3038-\\u303a',
        No:'\\u00b2\\u00b3\\u00b9\\u00bc-\\u00be\\u09f4-\\u09f9\\u0bf0-\\u0bf2\\u0f2a-\\u0f33\\u1369-\\u137c\\u17f0-\\u17f9\\u2070\\u2074-\\u2079\\u2080-\\u2089\\u2153-\\u215f\\u2460-\\u249b\\u24ea-\\u24ff\\u2776-\\u2793\\u2cfd\\u3192-\\u3195\\u3220-\\u3229\\u3251-\\u325f\\u3280-\\u3289\\u32b1-\\u32bf',
        Pc:'\\u005f\\u203f\\u2040\\u2054\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff3f',
        Pd:'\\u002d\\u058a\\u1806\\u2010-\\u2015\\u2e17\\u301c\\u3030\\u30a0\\ufe31\\ufe32\\ufe58\\ufe63\\uff0d',
        Pe:'\\u0029\\u005d\\u007d\\u0f3b\\u0f3d\\u169c\\u2046\\u207e\\u208e\\u232a\\u2769\\u276b\\u276d\\u276f\\u2771\\u2773\\u2775\\u27c6\\u27e7\\u27e9\\u27eb\\u2984\\u2986\\u2988\\u298a\\u298c\\u298e\\u2990\\u2992\\u2994\\u2996\\u2998\\u29d9\\u29db\\u29fd\\u3009\\u300b\\u300d\\u300f\\u3011\\u3015\\u3017\\u3019\\u301b\\u301e\\u301f\\ufd3f\\ufe18\\ufe36\\ufe38\\ufe3a\\ufe3c\\ufe3e\\ufe40\\ufe42\\ufe44\\ufe48\\ufe5a\\ufe5c\\ufe5e\\uff09\\uff3d\\uff5d\\uff60\\uff63',
        Pf:'\\u00bb\\u2019\\u201d\\u203a\\u2e03\\u2e05\\u2e0a\\u2e0d\\u2e1d',
        Pi:'\\u00ab\\u2018\\u201b\\u201c\\u201f\\u2039\\u2e02\\u2e04\\u2e09\\u2e0c\\u2e1c',
        Po:'\\u0021-\\u0023\\u0025-\\u0027\\u002a\\u002c\\u002e\\u002f\\u003a\\u003b\\u003f\\u0040\\u005c\\u00a1\\u00b7\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589\\u05be\\u05c0\\u05c3\\u05c6\\u05f3\\u05f4\\u060c\\u060d\\u061b\\u061e\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0964\\u0965\\u0970\\u0df4\\u0e4f\\u0e5a\\u0e5b\\u0f04-\\u0f12\\u0f85\\u0fd0\\u0fd1\\u104a-\\u104f\\u10fb\\u1361-\\u1368\\u166d\\u166e\\u16eb-\\u16ed\\u1735\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u1805\\u1807-\\u180a\\u1944\\u1945\\u19de\\u19df\\u1a1e\\u1a1f\\u1b5a-\\u1b60\\u2016\\u2017\\u2020-\\u2027\\u2030-\\u2038\\u203b-\\u203e\\u2041-\\u2043\\u2047-\\u2051\\u2053\\u2055-\\u205e\\u2cf9-\\u2cfc\\u2cfe\\u2cff\\u2e00\\u2e01\\u2e06-\\u2e08\\u2e0b\\u2e0e-\\u2e16\\u3001-\\u3003\\u303d\\u30fb\\ua874-\\ua877\\ufe10-\\ufe16\\ufe19\\ufe30\\ufe45\\ufe46\\ufe49-\\ufe4c\\ufe50-\\ufe52\\ufe54-\\ufe57\\ufe5f-\\ufe61\\ufe68\\ufe6a\\ufe6b\\uff01-\\uff03\\uff05-\\uff07\\uff0a\\uff0c\\uff0e\\uff0f\\uff1a\\uff1b\\uff1f\\uff20\\uff3c\\uff61\\uff64\\uff65',
        Ps:'\\u0028\\u005b\\u007b\\u0f3a\\u0f3c\\u169b\\u201a\\u201e\\u2045\\u207d\\u208d\\u2329\\u2768\\u276a\\u276c\\u276e\\u2770\\u2772\\u2774\\u27c5\\u27e6\\u27e8\\u27ea\\u2983\\u2985\\u2987\\u2989\\u298b\\u298d\\u298f\\u2991\\u2993\\u2995\\u2997\\u29d8\\u29da\\u29fc\\u3008\\u300a\\u300c\\u300e\\u3010\\u3014\\u3016\\u3018\\u301a\\u301d\\ufd3e\\ufe17\\ufe35\\ufe37\\ufe39\\ufe3b\\ufe3d\\ufe3f\\ufe41\\ufe43\\ufe47\\ufe59\\ufe5b\\ufe5d\\uff08\\uff3b\\uff5b\\uff5f\\uff62',
        Sc:'\\u0024\\u00a2-\\u00a5\\u060b\\u09f2\\u09f3\\u0af1\\u0bf9\\u0e3f\\u17db\\u20a0-\\u20b5\\ufdfc\\ufe69\\uff04\\uffe0\\uffe1\\uffe5\\uffe6',
        Sk:'\\u005e\\u0060\\u00a8\\u00af\\u00b4\\u00b8\\u02c2-\\u02c5\\u02d2-\\u02df\\u02e5-\\u02ed\\u02ef-\\u02ff\\u0374\\u0375\\u0384\\u0385\\u1fbd\\u1fbf-\\u1fc1\\u1fcd-\\u1fcf\\u1fdd-\\u1fdf\\u1fed-\\u1fef\\u1ffd\\u1ffe\\u309b\\u309c\\ua700-\\ua716\\ua720\\ua721\\uff3e\\uff40\\uffe3',
        Sm:'\\u002b\\u003c-\\u003e\\u007c\\u007e\\u00ac\\u00b1\\u00d7\\u00f7\\u03f6\\u2044\\u2052\\u207a-\\u207c\\u208a-\\u208c\\u2140-\\u2144\\u214b\\u2190-\\u2194\\u219a\\u219b\\u21a0\\u21a3\\u21a6\\u21ae\\u21ce\\u21cf\\u21d2\\u21d4\\u21f4-\\u22ff\\u2308-\\u230b\\u2320\\u2321\\u237c\\u239b-\\u23b3\\u23dc-\\u23e1\\u25b7\\u25c1\\u25f8-\\u25ff\\u266f\\u27c0-\\u27c4\\u27c7-\\u27ca\\u27d0-\\u27e5\\u27f0-\\u27ff\\u2900-\\u2982\\u2999-\\u29d7\\u29dc-\\u29fb\\u29fe-\\u2aff\\ufb29\\ufe62\\ufe64-\\ufe66\\uff0b\\uff1c-\\uff1e\\uff5c\\uff5e\\uffe2\\uffe9-\\uffec',
        So:'\\u00a6\\u00a7\\u00a9\\u00ae\\u00b0\\u00b6\\u0482\\u060e\\u060f\\u06e9\\u06fd\\u06fe\\u07f6\\u09fa\\u0b70\\u0bf3-\\u0bf8\\u0bfa\\u0cf1\\u0cf2\\u0f01-\\u0f03\\u0f13-\\u0f17\\u0f1a-\\u0f1f\\u0f34\\u0f36\\u0f38\\u0fbe-\\u0fc5\\u0fc7-\\u0fcc\\u0fcf\\u1360\\u1390-\\u1399\\u1940\\u19e0-\\u19ff\\u1b61-\\u1b6a\\u1b74-\\u1b7c\\u2100\\u2101\\u2103-\\u2106\\u2108\\u2109\\u2114\\u2116-\\u2118\\u211e-\\u2123\\u2125\\u2127\\u2129\\u212e\\u213a\\u213b\\u214a\\u214c\\u214d\\u2195-\\u2199\\u219c-\\u219f\\u21a1\\u21a2\\u21a4\\u21a5\\u21a7-\\u21ad\\u21af-\\u21cd\\u21d0\\u21d1\\u21d3\\u21d5-\\u21f3\\u2300-\\u2307\\u230c-\\u231f\\u2322-\\u2328\\u232b-\\u237b\\u237d-\\u239a\\u23b4-\\u23db\\u23e2-\\u23e7\\u2400-\\u2426\\u2440-\\u244a\\u249c-\\u24e9\\u2500-\\u25b6\\u25b8-\\u25c0\\u25c2-\\u25f7\\u2600-\\u266e\\u2670-\\u269c\\u26a0-\\u26b2\\u2701-\\u2704\\u2706-\\u2709\\u270c-\\u2727\\u2729-\\u274b\\u274d\\u274f-\\u2752\\u2756\\u2758-\\u275e\\u2761-\\u2767\\u2794\\u2798-\\u27af\\u27b1-\\u27be\\u2800-\\u28ff\\u2b00-\\u2b1a\\u2b20-\\u2b23\\u2ce5-\\u2cea\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u2ffb\\u3004\\u3012\\u3013\\u3020\\u3036\\u3037\\u303e\\u303f\\u3190\\u3191\\u3196-\\u319f\\u31c0-\\u31cf\\u3200-\\u321e\\u322a-\\u3243\\u3250\\u3260-\\u327f\\u328a-\\u32b0\\u32c0-\\u32fe\\u3300-\\u33ff\\u4dc0-\\u4dff\\ua490-\\ua4c6\\ua828-\\ua82b\\ufdfd\\uffe4\\uffe8\\uffed\\uffee\\ufffc\\ufffd',
        Zl:'\\u2028',
        Zp:'\\u2029',
        ZZ:'\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000',
        Zs:'\\u0020\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000'
    };

    Unicode.C = Unicode.Cc 
                + Unicode.Cf 
                + Unicode.Cs 
                + Unicode.Co ;
                //+ Unicode.Cn ; //This is not defined.

    Unicode.L = Unicode.Lu 
                + Unicode.Ll 
                + Unicode.Lt 
                + Unicode.Lm 
                + Unicode.Mn    //Added 2014-05-29 due to some letters in names not being recognized.
                                //This is where accent marks are individually combined instead of using an explicit character.
                + Unicode.Lo ;

    Unicode.LC= Unicode.Lu 
                + Unicode.Ll 
                + Unicode.Lt ;

    Unicode.M = Unicode.Mn 
                + Unicode.Mc 
                + Unicode.Me ;

    Unicode.N = Unicode.Nd 
                + Unicode.Nl 
                + Unicode.No ;

    Unicode.P = Unicode.Pc 
                + Unicode.Pd 
                + Unicode.Ps 
                + Unicode.Pe 
                + Unicode.Pi 
                + Unicode.Pf 
                + Unicode.Po ;

    Unicode.S = Unicode.Sm 
                + Unicode.Sc 
                + Unicode.Sk 
                + Unicode.So ;

    Unicode.Z = Unicode.Zs 
                + Unicode.Zl 
                + Unicode.Zp ;

    //Not in Unicode spec:
    Unicode.w = '_'
                + Unicode.L
                + Unicode.N ;

        //A Unicode based word boundry built with non-capturing parentheses
    Unicode.b = '(?:[' + Unicode.w + '](?:[^' + Unicode.w +']|$)'
                + '|(?:^|[^' + Unicode.w + '])[' + Unicode.w +']'
                + ')' ;

        //A Unicode based word boundry build with non-capturing parentheses
    Unicode.bOut = '(?=[^' + Unicode.w +']|$)';

        //A Unicode based word boundry build with non-capturing parentheses
        //JavaScript does not have a non-consuming look-behind.
        //This makes a direct replacement for \b not possible as we may consume
        // part of the string to make this test.
    Unicode.bIn = '(?:^|[^' + Unicode.w + '])';

        //A possible work-around is to use a capture and replace it.
    Unicode.bInCapture = '(?:^|([^' + Unicode.w + ']))';

        //A Unicode based non-word boundry build with non-capturing parentheses
    Unicode.B = '(?:[' + Unicode.w + '][' + Unicode.w +']'
            + '|[^' + Unicode.w + '][^' + Unicode.w +']'
            + ')' ;

    Unicode.d = Unicode.N ;

    class TokenError extends Error {
        constructor(msg, traceback) {
            super(msg);
            this.traceback = traceback;
        }
    }
    class pySyntaxError extends SyntaxError {
        constructor(msg, traceback) {
            super(msg);
            this.traceback = traceback;
        }
    }
    class IndentationError extends pySyntaxError {
    }
    class TokenInfo {
        constructor(type, string, start, end, line) {
            this.type = type;
            this.string = string;
            this.start = start;
            this.end = end;
            this.line = line;
        }
        get exact_type() {
            if (this.type === OP && this.string in EXACT_TOKEN_TYPES) {
                return EXACT_TOKEN_TYPES[this.string];
            }
            else {
                return this.type;
            }
        }
    }
    const reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    function regexEscape(string) {
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
    }
    const group = (...choices) => "(" + choices.join("|") + ")";
    const any = (...choices) => group(...choices) + "*";
    const maybe = (...choices) => group(...choices) + "?";
    function rstrip(input, what) {
        let i;
        for (i = input.length; i > 0; --i) {
            if (what.indexOf(input.charAt(i - 1)) === -1) {
                break;
            }
        }
        return input.substring(0, i);
    }
    const Whitespace = "[ \\f\\t]*";
    const Comment_ = "#[^\\r\\n]*";
    Whitespace + any("\\\\\\r?\\n" + Whitespace) + maybe(Comment_);
    const Name = "[" + Unicode.w + "]+";
    const Exponent = "[eE][-+]?[0-9](?:_?[0-9])*";
    const Pointfloat = group("[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?", "\\.[0-9](?:_?[0-9])*") + maybe(Exponent);
    const Expfloat = "[0-9](?:_?[0-9])*" + Exponent;
    const Floatnumber = group(Pointfloat, Expfloat);
    const Imagnumber = group("[0-9](?:_?[0-9])*[jJ]", Floatnumber + "[jJ]");
    // Return the empty string, plus all of the valid string prefixes.
    function _all_string_prefixes() {
        return ["", "FR", "RF", "Br", "BR", "Fr", "r", "B", "R", "b", "bR", "f", "rb", "rB", "F", "Rf", "U", "rF", "u", "RB", "br", "fR", "fr", "rf", "Rb"];
    }
    // Note that since _all_string_prefixes includes the empty string,
    //  StringPrefix can be the empty string (making it optional).
    const StringPrefix = group(..._all_string_prefixes());
    // these regexes differ from python because .exec doesn't do the
    // same thing as .match in python. It's more like .search.
    // .match matches from the start of the string.
    // to get the same behaviour we can add a ^ to the start of the
    // regex
    // Tail end of ' string.
    const Single = "^[^'\\\\]*(?:\\\\.[^'\\\\]*)*'";
    // Tail end of " string.
    const Double = '^[^"\\\\]*(?:\\\\.[^"\\\\]*)*"';
    // Tail end of ''' string.
    const Single3 = "^[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''";
    // Tail end of """ string.
    const Double3 = '^[^"\\\\]*(?:(?:\\\\.|"(?!""))[^"\\\\]*)*"""';
    const Triple = group(StringPrefix + "'''", StringPrefix + '"""');
    // Single-line ' or " string.
    group(StringPrefix + "'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'", StringPrefix + '"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*"');
    // Sorting in reverse order puts the long operators before their prefixes.
    // Otherwise if = came before ==, == would get recognized as two instances
    // of =.
    const EXACT_TOKENS_SORTED = Object.keys(EXACT_TOKEN_TYPES).sort();
    const Special = group(...EXACT_TOKENS_SORTED.reverse().map((t) => regexEscape(t)));
    const Funny = group("\\r?\\n", Special);
    const ContStr = group(StringPrefix + "'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*" + group("'", "\\\\\\r?\\n"), StringPrefix + '"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*' + group('"', "\\\\\\r?\\n"));
    const PseudoExtras = group("\\\\\\r?\\n|$", Comment_, Triple);
    // For a given string prefix plus quotes, endpats maps it to a regex
    //  to match the remainder of that string. _prefix can be empty, for
    //  a normal single or triple quoted string (with no prefix).
    const endpats = {};
    const prefixes = _all_string_prefixes();
    for (let _prefix of prefixes) {
        endpats[_prefix + "'"] = Single;
        endpats[_prefix + '"'] = Double;
        endpats[_prefix + "'''"] = Single3;
        endpats[_prefix + '"""'] = Double3;
    }
    // A set of all of the single and triple quoted string prefixes,
    //  including the opening quotes.
    const single_quoted = new Set();
    const triple_quoted = new Set();
    for (let t of prefixes) {
        single_quoted.add(t + '"');
        single_quoted.add(t + "'");
        triple_quoted.add(t + '"""');
        triple_quoted.add(t + "'''");
    }
    const tabsize = 8;
    const Hexnumber = "0[xX](?:_?[0-9a-fA-F])+";
    const Binnumber = "0[bB](?:_?[01])+";
    const Octnumber = "0[oO](?:_?[0-7])+";
    const Decnumber = "(?:0(?:_?0)*|[1-9](?:_?[0-9])*)";
    const Intnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber);
    const Number_ = group(Imagnumber, Floatnumber, Intnumber);
    const PseudoToken = Whitespace + group(PseudoExtras, Number_, Funny, ContStr, Name);
    const PseudoTokenRegexp = new RegExp(PseudoToken);
    // readline takes a callback that gets the next line and return undefined when it's done
    function tokenize(readline) {
        return _tokenize(readline);
    }
    function* _tokenize(readline, encoding, filename = "<tokenize>") {
        var lnum = 0, parenlev = 0, continued = 0, numchars = "0123456789", contstr = "", needcont = 0, contline = null, indents = [0], capos = null, endprog, strstart, end, pseudomatch;
        // since we don't do this with bytes this is not used
        if (encoding !== undefined) {
            if (encoding === "utf-8-sig") {
                // BOM will already have been stripped.
                encoding = "utf-8";
            }
            yield new TokenInfo(ENCODING, encoding, [0, 0], [0, 0], "");
        }
        var lasline = "";
        var line = "";
        while (true) {
            // loop over lines in stream
            // We capture the value of the line variable here because
            // readline uses the empty string '' to signal end of input,
            // hence `line` itself will always be overwritten at the end
            // of this loop.
            lasline = line;
            line = readline() || ""; // readline will return undefined when it's done
            // lets pretend this doesn't exist for now.
            // if encoding is not None:
            //     line = line.decode(encoding)
            lnum += 1;
            var pos = 0;
            var max = line.length;
            if (contstr) {
                // continued string
                if (!line) {
                    throw new TokenError("EOF in multi-line string", strstart);
                }
                endprog.lastIndex = 0;
                var endmatch = endprog.exec(line);
                if (endmatch) {
                    pos = end = endmatch[0].length;
                    yield new TokenInfo(STRING, contstr + line.substring(0, end), strstart, [lnum, end], contline + line);
                    contstr = "";
                    needcont = 0;
                    contline = null;
                }
                else if (needcont && line.substring(line.length - 2) !== "\\\n" && line.substring(line.length - 3) !== "\\\r\n") {
                    yield new TokenInfo(ERRORTOKEN, contstr + line, strstart, [lnum, line.length], contline);
                    contstr = "";
                    contline = null;
                    continue;
                }
                else {
                    contstr = contstr + line;
                    contline = contline + line;
                    continue;
                }
            }
            else if (parenlev === 0 && !continued) {
                // new statement
                if (!line) {
                    break;
                }
                var column = 0;
                while (pos < max) {
                    // measure leading whitespace
                    if (line[pos] === " ") {
                        column += 1;
                    }
                    else if (line[pos] === "\t") {
                        column = Math.floor(column / tabsize + 1) * tabsize;
                    }
                    else if (line[pos] === "\f") {
                        column = 0;
                    }
                    else {
                        break;
                    }
                    pos += 1;
                }
                if (pos === max) {
                    break;
                }
                if ("#\r\n".includes(line[pos])) {
                    // skip comments or blank lines
                    if (line[pos] === "#") {
                        const commentoken = rstrip(line.substring(pos), "\r\n");
                        yield new TokenInfo(COMMENT, commentoken, [lnum, pos], [lnum, pos + commentoken.length], line);
                        pos += commentoken.length;
                    }
                    yield new TokenInfo(NL, line.substring(pos), [lnum, pos], [lnum, line.length], line);
                    continue;
                }
                if (column > indents[indents.length - 1]) {
                    // count indents or dedents
                    indents.push(column);
                    yield new TokenInfo(INDENT, line.substring(pos), [lnum, 0], [lnum, pos], line);
                }
                while (column < indents[indents.length - 1]) {
                    if (!indents.includes(column)) {
                        throw new IndentationError("unindent does not match any outer indentation level", [filename, lnum, pos, line]);
                    }
                    indents = indents.slice(0, -1);
                    yield new TokenInfo(DEDENT, "", [lnum, pos], [lnum, pos], line);
                }
            }
            else {
                // continued statement
                if (!line) {
                    throw new TokenError("EOF in multi-line statement", [lnum, 0]);
                }
                continued = 0;
            }
            while (pos < max) {
                //console.log("pos:"+pos+":"+max);
                // js regexes don't return any info about matches, other than the
                // content. we'd like to put a \w+ before pseudomatch, but then we
                // can't get any data
                capos = line.charAt(pos);
                while (capos === " " || capos === "\f" || capos === "\t") {
                    pos += 1;
                    capos = line.charAt(pos);
                }
                pseudomatch = PseudoTokenRegexp.exec(line.substring(pos));
                if (pseudomatch) {
                    // scan for tokens
                    var start = pos;
                    var end = start + pseudomatch[1].length;
                    var spos = [lnum, start];
                    var epos = [lnum, end];
                    var pos = end;
                    if (start === end) {
                        continue;
                    }
                    var token = line.substring(start, end);
                    var initial = line[start];
                    //console.log("token:",token, "initial:",initial, start, end);
                    if (numchars.includes(initial) || // ordinary number
                        (initial === "." && token !== "." && token !== "...")) {
                        yield new TokenInfo(NUMBER, token, spos, epos, line);
                    }
                    else if ("\r\n".includes(initial)) {
                        if (parenlev > 0) {
                            yield new TokenInfo(NL, token, spos, epos, line);
                        }
                        else {
                            yield new TokenInfo(NEWLINE, token, spos, epos, line);
                        }
                    }
                    else if (initial === "#") {
                        //assert not token.endswith("\n")
                        yield new TokenInfo(COMMENT, token, spos, epos, line);
                    }
                    else if (triple_quoted.has(token)) {
                        endprog = RegExp(endpats[token]);
                        endmatch = endprog.exec(line.substring(pos));
                        if (endmatch) {
                            // all on one line
                            pos = endmatch[0].length + pos;
                            token = line.substring(start, pos);
                            yield new TokenInfo(STRING, token, spos, [lnum, pos], line);
                        }
                        else {
                            strstart = [lnum, start]; // multiple lines
                            contstr = line.substring(start);
                            contline = line;
                            break;
                        }
                        // Check up to the first 3 chars of the token to see if
                        //  they're in the single_quoted set. If so, they start
                        //  a string.
                        // We're using the first 3, because we're looking for
                        //  "rb'" (for example) at the start of the token. If
                        //  we switch to longer prefixes, this needs to be
                        //  adjusted.
                        // Note that initial == token[:1].
                        // Also note that single quote checking must come after
                        //  triple quote checking (above).
                    }
                    else if (single_quoted.has(initial) || single_quoted.has(token.substring(0, 2)) || single_quoted.has(token.substring(0, 3))) {
                        if (token[token.length - 1] === "\n") {
                            // continued string
                            strstart = [lnum, start];
                            // Again, using the first 3 chars of the
                            //  token. This is looking for the matching end
                            //  regex for the correct type of quote
                            //  character. So it's really looking for
                            //  endpats["'"] or endpats['"'], by trying to
                            //  skip string prefix characters, if any.
                            endprog = RegExp(endpats[initial] || endpats[token[1]] || endpats[token[2]]);
                            contstr = line.substring(start);
                            needcont = 1;
                            contline = line;
                            break;
                        }
                        else {
                            // ordinary string
                            yield new TokenInfo(STRING, token, spos, epos, line);
                        }
                    }
                    else if (initial.isIdentifier()) {
                        // ordinary name
                        yield new TokenInfo(NAME, token, spos, epos, line);
                    }
                    else if (initial === "\\") {
                        // continued stmt
                        continued = 1;
                    }
                    else {
                        if ("([{".includes(initial)) {
                            parenlev += 1;
                        }
                        else if (")]}".includes(initial)) {
                            parenlev -= 1;
                        }
                        yield new TokenInfo(OP, token, spos, epos, line);
                    }
                }
                else {
                    yield new TokenInfo(ERRORTOKEN, line[pos], [lnum, pos], [lnum, pos + 1], line);
                    pos += 1;
                }
            }
        }
        // Add an implicit NEWLINE if the input doesn't end in one
        if (lasline && !"\r\n".includes(lasline[lasline.length - 1])) {
            yield new TokenInfo(NEWLINE, "", [lnum - 1, lasline.length], [lnum - 1, lasline.length + 1], "");
        }
        for (let _ in indents.slice(1)) {
            // pop remaining indent levels
            yield new TokenInfo(DEDENT, "", [lnum, 0], [lnum, 0], "");
        }
        yield new TokenInfo(ENDMARKER, "", [lnum, 0], [lnum, 0], "");
    }

    class Load$1 {
    }
    class Name$1 {
        constructor(id, ctx, lineno, col_offset, end_lineno, end_col_offset) {
            this.id = id;
            this.ctx = ctx;
            this.lineno = lineno;
            this.col_offset = col_offset;
            this.end_lineno = end_lineno;
            this.end_col_offset = end_col_offset;
        }
    }
    function logger(
    // """For non-memoized functions that we want to be logged.
    // (In practice this is only non-leader left-recursive functions.)
    // """
    target, propertyKey, descriptor) {
        const method = descriptor.value;
        const method_name = propertyKey;
        function logger_wrapper(...args) {
            if (!this._verbose) {
                return method.call(this, ...args);
            }
            const fill = "  ".repeat(this._level);
            console.log(`${fill}${method_name}(${args}) .... (looking at ${this.showpeek()
            .toString()
            .slice(0, 200)})`);
            this._level++;
            const tree = method.call(this, ...args);
            this._level--;
            console.log(`${fill}... ${method_name}(${args}) --> ${String(tree).slice(0, 200)}`);
            return tree;
        }
        descriptor.value = logger_wrapper;
    }
    function memoize(target, propertyKey, descriptor) {
        const method = descriptor.value;
        const method_name = propertyKey;
        function memoize_wrapper(...args) {
            let mark = this.mark();
            let key = [mark, method_name, args].toString();
            // fast path: cache hit and not verbose
            if (key in this._cache && !this._verbose) {
                // work out how to _cache
                const [tree, endmark] = this._cache[key];
                this.reset(endmark);
                return tree;
            }
            // slow path verbose or cache not hit
            const verbose = this._verbose;
            const fill = "  ".repeat(this._level);
            let tree, endmark;
            if (!(key in this._cache)) {
                if (verbose) {
                    console.log(`${fill}${method_name}(${args}) ... (looking at ${this.showpeek()
                    .toString()
                    .slice(0, 200)})`);
                }
                this._level++;
                tree = method.call(this, ...args);
                this._level--;
                if (verbose) {
                    console.log(`${fill}... ${method_name}(${args}) -> ${String(tree).slice(0, 200)}`);
                }
                endmark = this.mark();
                this._cache[key] = [tree, endmark];
            }
            else {
                [tree, endmark] = this._cache[key];
                if (verbose) {
                    console.log(`${fill}${method_name}(${args}) -> ${String(tree).slice(200)}`);
                }
                this.reset(endmark);
            }
            return tree;
        }
        descriptor.value = memoize_wrapper;
    }
    function memoize_left_rec(target, propertyKey, descriptor) {
        const method = descriptor.value;
        const method_name = propertyKey;
        function memoize_left_rec_wrapper() {
            let mark = this.mark();
            let key = [mark, method_name, []].toString();
            let endmark, tree;
            // fastpath cache hit and not verbose
            if (key in this._cache && !this._verbose) {
                [tree, endmark] = this._cache[key];
                this.reset(endmark);
                return tree;
            }
            // # Slow path: no cache hit, or verbose.
            const verbose = this._verbose;
            const fill = "  ".repeat(this._level);
            if (!(key in this._cache)) {
                if (verbose) {
                    console.log(`${fill}${method_name} ... (looking at ${this.showpeek()})`);
                }
                this._level++;
                /*
                      # For left-recursive rules we manipulate the cache and
                      # loop until the rule shows no progress, then pick the
                      # previous result.  For an explanation why this works, see
                      # https://github.com/PhilippeSigaud/Pegged/wiki/Left-Recursion
                      # (But we use the memoization cache instead of a static
                      # variable; perhaps this is similar to a paper by Warth et al.
                      # (http://web.cs.ucla.edu/~todd/research/pub.php?id=pepm08).
          
                      # Prime the cache with a failure.
                      */
                let [lastresult, lastmark] = (this._cache[key] = [null, mark]);
                let depth = 0;
                if (verbose) {
                    console.log(`${fill}Recursive ${method_name} at ${mark} depth ${depth}`);
                }
                while (true) {
                    this.reset(mark);
                    const result = method.call(this);
                    endmark = this.mark();
                    depth++;
                    if (verbose) {
                        console.log(`${fill}Recursive ${method_name} at ${mark} depth ${depth}: ${String(result).slice(0, 200)} to ${endmark}`);
                    }
                    if (!result) {
                        if (verbose) {
                            console.log(`${fill}Fail with ${String(lastresult).slice(0, 200)} to ${lastmark}`);
                        }
                        break;
                    }
                    if (endmark <= lastmark) {
                        if (verbose) {
                            console.log(`${fill}Bailing with ${String(lastresult).slice(0, 200)} to ${lastmark}`);
                        }
                        break;
                    }
                    this._cache[key] = [lastresult, lastmark] = [result, endmark];
                }
                this.reset(lastmark);
                tree = lastresult;
                this._level--;
                if (verbose) {
                    console.log(`${fill}${method_name}() -> ${String(tree).slice(0, 200)} [cached]`);
                }
                if (tree) {
                    endmark = this.mark();
                }
                else {
                    endmark = mark;
                    this.reset(endmark);
                }
                this._cache[key] = [tree, endmark];
            }
            else {
                [tree, endmark] = this._cache[key];
                if (verbose) {
                    console.log(`${fill}${method_name}() -> ${String(tree).slice(0, 200)} [fresh]`);
                }
                if (tree) {
                    this.reset(endmark);
                }
            }
            return tree;
        }
        descriptor.value = memoize_left_rec_wrapper;
    }
    class Parser {
        constructor(tokenizer, verbose = false) {
            this._tokenizer = tokenizer;
            this._verbose = verbose;
            this._level = 0;
            this._cache = {};
            this.mark = this._tokenizer.mark.bind(this._tokenizer);
            this.reset = this._tokenizer.reset.bind(this._tokenizer);
            this._tokens = this._tokenizer._tokens;
        }
        start() {
            return null;
        }
        showpeek() {
            const tok = this._tokenizer.peek();
            return `${tok.start[0]}.${tok.start[1]}: ${tok_name[tok.type]}:'${tok.string}'`;
        }
        name() {
            let tok = this._tokenizer.peek();
            if (tok.type === NAME) {
                tok = this._tokenizer.getnext();
                return new Name$1(tok.string, new Load$1(), tok.start[0], tok.start[1], tok.end[0], tok.end[1]);
            }
            return null;
        }
        string() {
            const tok = this._tokenizer.peek();
            if (tok.type === STRING) {
                return this._tokenizer.getnext();
            }
            return null;
        }
        number() {
            const tok = this._tokenizer.peek();
            if (tok.type === NUMBER) {
                return this._tokenizer.getnext();
            }
            return null;
        }
        op() {
            const tok = this._tokenizer.peek();
            if (tok.type === OP) {
                return this._tokenizer.getnext();
            }
            return null;
        }
        expect(type) {
            const tok = this._tokenizer.peek();
            if (tok.string === type) {
                return this._tokenizer.getnext();
            }
            if (type in exact_token_types) {
                if (tok.type === exact_token_types[type]) {
                    return this._tokenizer.getnext();
                }
            }
            if (type in tokens$1) {
                if (tok.type === tokens$1[type]) {
                    return this._tokenizer.getnext();
                }
            }
            if (tok.type === OP && tok.string === type) {
                return this._tokenizer.getnext();
            }
            return null;
        }
        positive_lookahead(func, ...args) {
            const mark = this.mark();
            const ok = func.call(this, ...args);
            this.reset(mark);
            return ok;
        }
        negative_lookahead(func, ...args) {
            const mark = this.mark();
            const ok = func.call(this, ...args);
            this.reset(mark);
            return !ok;
        }
        make_syntax_error(filename = "<unknown>") {
            const tok = this._tokenizer.diagnose();
            return new pySyntaxError("pegen parse failure", [
                filename,
                tok.start[0],
                1 + tok.start[1],
                tok.line,
            ]);
        }
    }
    __decorate([
        memoize
    ], Parser.prototype, "name", null);
    __decorate([
        memoize
    ], Parser.prototype, "number", null);
    __decorate([
        memoize
    ], Parser.prototype, "op", null);
    __decorate([
        memoize
    ], Parser.prototype, "expect", null);

    // #!/usr/bin/env python3.8
    const EXTRA = []; // todo
    const pegen = new Proxy({}, { get: () => (...args) => args });
    class GeneratedParser extends Parser {
        file() {
            //# file: statements? $
            let a, mark;
            mark = this.mark();
            if ((a = this.statements() || 1) && (this.expect("ENDMARKER"))) {
                return pegen.make_module(a);
            }
            this.reset(mark);
            return null;
        }
        interactive() {
            //# interactive: statement_newline
            let a, mark;
            mark = this.mark();
            if ((a = this.statement_newline())) {
                return new Interactive(a);
            }
            this.reset(mark);
            return null;
        }
        eval() {
            //# eval: expressions NEWLINE* $
            let a, mark;
            mark = this.mark();
            if ((a = this.expressions()) && (this._loop0_1()) && (this.expect("ENDMARKER"))) {
                return new Expression(a);
            }
            this.reset(mark);
            return null;
        }
        func_type() {
            //# func_type: '(' type_expressions? ')' '->' expression NEWLINE* $
            let a, b, mark;
            mark = this.mark();
            if ((this.expect("(")) &&
                (a = this.type_expressions() || 1) &&
                (this.expect(")")) &&
                (this.expect("->")) &&
                (b = this.expression()) &&
                (this._loop0_2()) &&
                (this.expect("ENDMARKER"))) {
                return new FunctionType(a, b);
            }
            this.reset(mark);
            return null;
        }
        fstring() {
            //# fstring: star_expressions
            let mark, star_expressions;
            mark = this.mark();
            if ((star_expressions = this.star_expressions())) {
                return star_expressions;
            }
            this.reset(mark);
            return null;
        }
        type_expressions() {
            //# type_expressions: ','.expression+ ',' '*' expression ',' '**' expression | ','.expression+ ',' '*' expression | ','.expression+ ',' '**' expression | '*' expression ',' '**' expression | '*' expression | '**' expression | ','.expression+
            let a, b, c, mark;
            mark = this.mark();
            if ((a = this._gather_3()) &&
                (this.expect(",")) &&
                (this.expect("*")) &&
                (b = this.expression()) &&
                (this.expect(",")) &&
                (this.expect("**")) &&
                (c = this.expression())) {
                return pegen.seq_append_to_end(pegen.seq_append_to_end(a, b), c);
            }
            this.reset(mark);
            if ((a = this._gather_5()) && (this.expect(",")) && (this.expect("*")) && (b = this.expression())) {
                return pegen.seq_append_to_end(a, b);
            }
            this.reset(mark);
            if ((a = this._gather_7()) && (this.expect(",")) && (this.expect("**")) && (b = this.expression())) {
                return pegen.seq_append_to_end(a, b);
            }
            this.reset(mark);
            if ((this.expect("*")) && (a = this.expression()) && (this.expect(",")) && (this.expect("**")) && (b = this.expression())) {
                return pegen.seq_append_to_end(pegen.singleton_seq(a), b);
            }
            this.reset(mark);
            if ((this.expect("*")) && (a = this.expression())) {
                return pegen.singleton_seq(a);
            }
            this.reset(mark);
            if ((this.expect("**")) && (a = this.expression())) {
                return pegen.singleton_seq(a);
            }
            this.reset(mark);
            if ((a = this._gather_9())) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        statements() {
            //# statements: statement+
            let a, mark;
            mark = this.mark();
            if ((a = this._loop1_11())) {
                return pegen.seq_flatten(a);
            }
            this.reset(mark);
            return null;
        }
        statement() {
            //# statement: compound_stmt | simple_stmts
            let a, mark;
            mark = this.mark();
            if ((a = this.compound_stmt())) {
                return pegen.singleton_seq(a);
            }
            this.reset(mark);
            if ((a = this.simple_stmts())) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        statement_newline() {
            //# statement_newline: compound_stmt NEWLINE | simple_stmts | NEWLINE | $
            let a, mark, simple_stmts;
            mark = this.mark();
            if ((a = this.compound_stmt()) && (this.expect("NEWLINE"))) {
                return pegen.singleton_seq(a);
            }
            this.reset(mark);
            if ((simple_stmts = this.simple_stmts())) {
                return simple_stmts;
            }
            this.reset(mark);
            if ((this.expect("NEWLINE"))) {
                return pegen.singleton_seq(new Pass(...EXTRA));
            }
            this.reset(mark);
            if ((this.expect("ENDMARKER"))) {
                return pegen.interactive_exit(p);
            }
            this.reset(mark);
            return null;
        }
        simple_stmts() {
            //# simple_stmts: simple_stmt !';' NEWLINE | ';'.simple_stmt+ ';'? NEWLINE
            let a, mark;
            mark = this.mark();
            if ((a = this.simple_stmt()) && this.negative_lookahead(this.expect, ";") && (this.expect("NEWLINE"))) {
                return pegen.singleton_seq(a);
            }
            this.reset(mark);
            if ((a = this._gather_12()) && (this.expect(";") || 1) && (this.expect("NEWLINE"))) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        simple_stmt() {
            //# simple_stmt: assignment | star_expressions | &'return' return_stmt | &('import' | 'from') import_stmt | &'raise' raise_stmt | 'pass' | &'del' del_stmt | &'yield' yield_stmt | &'assert' assert_stmt | 'break' | 'continue' | &'global' global_stmt | &'nonlocal' nonlocal_stmt
            let assert_stmt, assignment, del_stmt, e, global_stmt, import_stmt, mark, nonlocal_stmt, raise_stmt, return_stmt, yield_stmt;
            mark = this.mark();
            if ((assignment = this.assignment())) {
                return assignment;
            }
            this.reset(mark);
            if ((e = this.star_expressions())) {
                return new Expr(e, ...EXTRA);
            }
            this.reset(mark);
            if (this.positive_lookahead(this.expect, "return") && (return_stmt = this.return_stmt())) {
                return return_stmt;
            }
            this.reset(mark);
            if (this.positive_lookahead(this._tmp_14) && (import_stmt = this.import_stmt())) {
                return import_stmt;
            }
            this.reset(mark);
            if (this.positive_lookahead(this.expect, "raise") && (raise_stmt = this.raise_stmt())) {
                return raise_stmt;
            }
            this.reset(mark);
            if ((this.expect("pass"))) {
                return new Pass(...EXTRA);
            }
            this.reset(mark);
            if (this.positive_lookahead(this.expect, "del") && (del_stmt = this.del_stmt())) {
                return del_stmt;
            }
            this.reset(mark);
            if (this.positive_lookahead(this.expect, "yield") && (yield_stmt = this.yield_stmt())) {
                return yield_stmt;
            }
            this.reset(mark);
            if (this.positive_lookahead(this.expect, "assert") && (assert_stmt = this.assert_stmt())) {
                return assert_stmt;
            }
            this.reset(mark);
            if ((this.expect("break"))) {
                return new Break(...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("continue"))) {
                return new Continue(...EXTRA);
            }
            this.reset(mark);
            if (this.positive_lookahead(this.expect, "global") && (global_stmt = this.global_stmt())) {
                return global_stmt;
            }
            this.reset(mark);
            if (this.positive_lookahead(this.expect, "nonlocal") && (nonlocal_stmt = this.nonlocal_stmt())) {
                return nonlocal_stmt;
            }
            this.reset(mark);
            return null;
        }
        compound_stmt() {
            //# compound_stmt: &('def' | '@' | ASYNC) function_def | &'if' if_stmt | &('class' | '@') class_def | &('with' | ASYNC) with_stmt | &('for' | ASYNC) for_stmt | &'try' try_stmt | &'while' while_stmt
            let class_def, for_stmt, function_def, if_stmt, mark, try_stmt, while_stmt, with_stmt;
            mark = this.mark();
            if (this.positive_lookahead(this._tmp_15) && (function_def = this.function_def())) {
                return function_def;
            }
            this.reset(mark);
            if (this.positive_lookahead(this.expect, "if") && (if_stmt = this.if_stmt())) {
                return if_stmt;
            }
            this.reset(mark);
            if (this.positive_lookahead(this._tmp_16) && (class_def = this.class_def())) {
                return class_def;
            }
            this.reset(mark);
            if (this.positive_lookahead(this._tmp_17) && (with_stmt = this.with_stmt())) {
                return with_stmt;
            }
            this.reset(mark);
            if (this.positive_lookahead(this._tmp_18) && (for_stmt = this.for_stmt())) {
                return for_stmt;
            }
            this.reset(mark);
            if (this.positive_lookahead(this.expect, "try") && (try_stmt = this.try_stmt())) {
                return try_stmt;
            }
            this.reset(mark);
            if (this.positive_lookahead(this.expect, "while") && (while_stmt = this.while_stmt())) {
                return while_stmt;
            }
            this.reset(mark);
            return null;
        }
        assignment() {
            //# assignment: NAME ':' expression ['=' annotated_rhs] | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs] | ((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT? | single_target augassign ~ (yield_expr | star_expressions) | invalid_assignment
            let a, b, c, cut, invalid_assignment, mark, tc;
            mark = this.mark();
            if ((a = this.name()) && (this.expect(":")) && (b = this.expression()) && (c = this._tmp_19() || 1)) {
                return CHECK_VERSION(6, "Variable annotation syntax is", new AnnAssign(pegen.set_expr_context(a, new Store()), b, c, 1, ...EXTRA));
            }
            this.reset(mark);
            if ((a = this._tmp_20()) && (this.expect(":")) && (b = this.expression()) && (c = this._tmp_21() || 1)) {
                return CHECK_VERSION(6, "Variable annotations syntax is", new AnnAssign(a, b, c, 0, ...EXTRA));
            }
            this.reset(mark);
            if ((a = this._loop1_22()) && (b = this._tmp_23()) && this.negative_lookahead(this.expect, "=") && (tc = this.expect("TYPE_COMMENT") || 1)) {
                return new Assign(a, b, NEW_TYPE_COMMENT(tc), ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.single_target()) && (b = this.augassign()) && (cut = true) && (c = this._tmp_24())) {
                return new AugAssign(a, b.kind, c, ...EXTRA);
            }
            this.reset(mark);
            if (cut)
                return null;
            cut = false;
            if ((invalid_assignment = this.invalid_assignment())) {
                return invalid_assignment;
            }
            this.reset(mark);
            return null;
        }
        augassign() {
            //# augassign: '+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='
            let mark;
            mark = this.mark();
            if ((this.expect("+="))) {
                return new Add();
            }
            this.reset(mark);
            if ((this.expect("-="))) {
                return new Sub();
            }
            this.reset(mark);
            if ((this.expect("*="))) {
                return new Mult();
            }
            this.reset(mark);
            if ((this.expect("@="))) {
                return CHECK_VERSION(new AugOperator(), 5, "The '@' operator is", new MatMult());
            }
            this.reset(mark);
            if ((this.expect("/="))) {
                return new Div();
            }
            this.reset(mark);
            if ((this.expect("%="))) {
                return new Mod();
            }
            this.reset(mark);
            if ((this.expect("&="))) {
                return new BitAnd();
            }
            this.reset(mark);
            if ((this.expect("|="))) {
                return new BitOr();
            }
            this.reset(mark);
            if ((this.expect("^="))) {
                return new BitXor();
            }
            this.reset(mark);
            if ((this.expect("<<="))) {
                return new LShift();
            }
            this.reset(mark);
            if ((this.expect(">>="))) {
                return new RShift();
            }
            this.reset(mark);
            if ((this.expect("**="))) {
                return new Pow();
            }
            this.reset(mark);
            if ((this.expect("//="))) {
                return new FloorDiv();
            }
            this.reset(mark);
            return null;
        }
        global_stmt() {
            //# global_stmt: 'global' ','.NAME+
            let a, mark;
            mark = this.mark();
            if ((this.expect("global")) && (a = this._gather_25())) {
                return new Global(pegen.map_names_to_ids(a), ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        nonlocal_stmt() {
            //# nonlocal_stmt: 'nonlocal' ','.NAME+
            let a, mark;
            mark = this.mark();
            if ((this.expect("nonlocal")) && (a = this._gather_27())) {
                return new Nonlocal(pegen.map_names_to_ids(a), ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        yield_stmt() {
            //# yield_stmt: yield_expr
            let mark, y;
            mark = this.mark();
            if ((y = this.yield_expr())) {
                return new Expr(y, ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        assert_stmt() {
            //# assert_stmt: 'assert' expression [',' expression]
            let a, b, mark;
            mark = this.mark();
            if ((this.expect("assert")) && (a = this.expression()) && (b = this._tmp_29() || 1)) {
                return new Assert(a, b, ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        del_stmt() {
            //# del_stmt: 'del' del_targets &(';' | NEWLINE) | invalid_del_stmt
            let a, invalid_del_stmt, mark;
            mark = this.mark();
            if ((this.expect("del")) && (a = this.del_targets()) && this.positive_lookahead(this._tmp_30)) {
                return new Delete(a, ...EXTRA);
            }
            this.reset(mark);
            if ((invalid_del_stmt = this.invalid_del_stmt())) {
                return invalid_del_stmt;
            }
            this.reset(mark);
            return null;
        }
        import_stmt() {
            //# import_stmt: import_name | import_from
            let import_from, import_name, mark;
            mark = this.mark();
            if ((import_name = this.import_name())) {
                return import_name;
            }
            this.reset(mark);
            if ((import_from = this.import_from())) {
                return import_from;
            }
            this.reset(mark);
            return null;
        }
        import_name() {
            //# import_name: 'import' dotted_as_names
            let a, mark;
            mark = this.mark();
            if ((this.expect("import")) && (a = this.dotted_as_names())) {
                return new Import(a, ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        import_from() {
            //# import_from: 'from' (('.' | '...'))* dotted_name 'import' import_from_targets | 'from' (('.' | '...'))+ 'import' import_from_targets
            let a, b, c, mark;
            mark = this.mark();
            if ((this.expect("from")) && (a = this._loop0_31()) && (b = this.dotted_name()) && (this.expect("import")) && (c = this.import_from_targets())) {
                return new ImportFrom(b.id, c, pegen.seq_count_dots(a), ...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("from")) && (a = this._loop1_32()) && (this.expect("import")) && (b = this.import_from_targets())) {
                return new ImportFrom(null, b, pegen.seq_count_dots(a), ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        import_from_targets() {
            //# import_from_targets: '(' import_from_as_names ','? ')' | import_from_as_names !',' | '*' | invalid_import_from_targets
            let a, import_from_as_names, invalid_import_from_targets, mark;
            mark = this.mark();
            if ((this.expect("(")) && (a = this.import_from_as_names()) && (this.expect(",") || 1) && (this.expect(")"))) {
                return a;
            }
            this.reset(mark);
            if ((import_from_as_names = this.import_from_as_names()) && this.negative_lookahead(this.expect, ",")) {
                return import_from_as_names;
            }
            this.reset(mark);
            if ((this.expect("*"))) {
                return pegen.singleton_seq((alias_ty, pegen.alias_for_star(p)));
            }
            this.reset(mark);
            if ((invalid_import_from_targets = this.invalid_import_from_targets())) {
                return invalid_import_from_targets;
            }
            this.reset(mark);
            return null;
        }
        import_from_as_names() {
            //# import_from_as_names: ','.import_from_as_name+
            let a, mark;
            mark = this.mark();
            if ((a = this._gather_33())) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        import_from_as_name() {
            //# import_from_as_name: NAME ['as' NAME]
            let a, b, mark;
            mark = this.mark();
            if ((a = this.name()) && (b = this._tmp_35() || 1)) {
                return new alias(a.id, b.id);
            }
            this.reset(mark);
            return null;
        }
        dotted_as_names() {
            //# dotted_as_names: ','.dotted_as_name+
            let a, mark;
            mark = this.mark();
            if ((a = this._gather_36())) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        dotted_as_name() {
            //# dotted_as_name: dotted_name ['as' NAME]
            let a, b, mark;
            mark = this.mark();
            if ((a = this.dotted_name()) && (b = this._tmp_38() || 1)) {
                return new alias(a.id, b.id);
            }
            this.reset(mark);
            return null;
        }
        dotted_name() {
            //# dotted_name: dotted_name '.' NAME | NAME
            let a, b, mark, name;
            mark = this.mark();
            if ((a = this.dotted_name()) && (this.expect(".")) && (b = this.name())) {
                return pegen.join_names_with_dot(a, b);
            }
            this.reset(mark);
            if ((name = this.name())) {
                return name;
            }
            this.reset(mark);
            return null;
        }
        if_stmt() {
            //# if_stmt: 'if' named_expression ':' block elif_stmt | 'if' named_expression ':' block else_block?
            let a, b, c, mark;
            mark = this.mark();
            if ((this.expect("if")) && (a = this.named_expression()) && (this.expect(":")) && (b = this.block()) && (c = this.elif_stmt())) {
                return new If(a, b, pegen.singleton_seq(c), ...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("if")) && (a = this.named_expression()) && (this.expect(":")) && (b = this.block()) && (c = this.else_block() || 1)) {
                return new If(a, b, c, ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        elif_stmt() {
            //# elif_stmt: 'elif' named_expression ':' block elif_stmt | 'elif' named_expression ':' block else_block?
            let a, b, c, mark;
            mark = this.mark();
            if ((this.expect("elif")) && (a = this.named_expression()) && (this.expect(":")) && (b = this.block()) && (c = this.elif_stmt())) {
                return new If(a, b, pegen.singleton_seq(c), ...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("elif")) && (a = this.named_expression()) && (this.expect(":")) && (b = this.block()) && (c = this.else_block() || 1)) {
                return new If(a, b, c, ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        else_block() {
            //# else_block: 'else' ':' block
            let b, mark;
            mark = this.mark();
            if ((this.expect("else")) && (this.expect(":")) && (b = this.block())) {
                return b;
            }
            this.reset(mark);
            return null;
        }
        while_stmt() {
            //# while_stmt: 'while' named_expression ':' block else_block?
            let a, b, c, mark;
            mark = this.mark();
            if ((this.expect("while")) && (a = this.named_expression()) && (this.expect(":")) && (b = this.block()) && (c = this.else_block() || 1)) {
                return new While(a, b, c, ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        for_stmt() {
            //# for_stmt: 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block? | ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block? | invalid_for_target
            let b, cut, el, ex, invalid_for_target, mark, t, tc;
            mark = this.mark();
            if ((this.expect("for")) &&
                (t = this.star_targets()) &&
                (this.expect("in")) &&
                (cut = true) &&
                (ex = this.star_expressions()) &&
                (this.expect(":")) &&
                (tc = this.expect("TYPE_COMMENT") || 1) &&
                (b = this.block()) &&
                (el = this.else_block() || 1)) {
                return new For(t, ex, b, el, NEW_TYPE_COMMENT(tc), ...EXTRA);
            }
            this.reset(mark);
            if (cut)
                return null;
            cut = false;
            if ((this.expect("ASYNC")) &&
                (this.expect("for")) &&
                (t = this.star_targets()) &&
                (this.expect("in")) &&
                (cut = true) &&
                (ex = this.star_expressions()) &&
                (this.expect(":")) &&
                (tc = this.expect("TYPE_COMMENT") || 1) &&
                (b = this.block()) &&
                (el = this.else_block() || 1)) {
                return CHECK_VERSION(5, "Async for loops are", new AsyncFor(t, ex, b, el, NEW_TYPE_COMMENT(tc), ...EXTRA));
            }
            this.reset(mark);
            if (cut)
                return null;
            cut = false;
            if ((invalid_for_target = this.invalid_for_target())) {
                return invalid_for_target;
            }
            this.reset(mark);
            return null;
        }
        with_stmt() {
            //# with_stmt: 'with' '(' ','.with_item+ ','? ')' ':' block | 'with' ','.with_item+ ':' TYPE_COMMENT? block | ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block | ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block
            let a, b, mark, tc;
            mark = this.mark();
            if ((this.expect("with")) &&
                (this.expect("(")) &&
                (a = this._gather_39()) &&
                (this.expect(",") || 1) &&
                (this.expect(")")) &&
                (this.expect(":")) &&
                (b = this.block())) {
                return new With(a, b, null, ...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("with")) && (a = this._gather_41()) && (this.expect(":")) && (tc = this.expect("TYPE_COMMENT") || 1) && (b = this.block())) {
                return new With(a, b, NEW_TYPE_COMMENT(tc), ...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("ASYNC")) &&
                (this.expect("with")) &&
                (this.expect("(")) &&
                (a = this._gather_43()) &&
                (this.expect(",") || 1) &&
                (this.expect(")")) &&
                (this.expect(":")) &&
                (b = this.block())) {
                return CHECK_VERSION(5, "Async with statements are", new AsyncWith(a, b, null, ...EXTRA));
            }
            this.reset(mark);
            if ((this.expect("ASYNC")) &&
                (this.expect("with")) &&
                (a = this._gather_45()) &&
                (this.expect(":")) &&
                (tc = this.expect("TYPE_COMMENT") || 1) &&
                (b = this.block())) {
                return CHECK_VERSION(5, "Async with statements are", new AsyncWith(a, b, NEW_TYPE_COMMENT(tc), ...EXTRA));
            }
            this.reset(mark);
            return null;
        }
        with_item() {
            //# with_item: expression 'as' star_target &(',' | ')' | ':') | invalid_with_item | expression
            let e, invalid_with_item, mark, t;
            mark = this.mark();
            if ((e = this.expression()) && (this.expect("as")) && (t = this.star_target()) && this.positive_lookahead(this._tmp_47)) {
                return new withitem(e, t);
            }
            this.reset(mark);
            if ((invalid_with_item = this.invalid_with_item())) {
                return invalid_with_item;
            }
            this.reset(mark);
            if ((e = this.expression())) {
                return new withitem(e, null);
            }
            this.reset(mark);
            return null;
        }
        try_stmt() {
            //# try_stmt: 'try' ':' block finally_block | 'try' ':' block except_block+ else_block? finally_block?
            let b, el, ex, f, mark;
            mark = this.mark();
            if ((this.expect("try")) && (this.expect(":")) && (b = this.block()) && (f = this.finally_block())) {
                return new Try(b, null, null, f, ...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("try")) && (this.expect(":")) && (b = this.block()) && (ex = this._loop1_48()) && (el = this.else_block() || 1) && (f = this.finally_block() || 1)) {
                return new Try(b, ex, el, f, ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        except_block() {
            //# except_block: 'except' expression ['as' NAME] ':' block | 'except' ':' block
            let b, e, mark, t;
            mark = this.mark();
            if ((this.expect("except")) && (e = this.expression()) && (t = this._tmp_49() || 1) && (this.expect(":")) && (b = this.block())) {
                return new ExceptHandler(e, t.id, b, ...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("except")) && (this.expect(":")) && (b = this.block())) {
                return new ExceptHandler(null, null, b, ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        finally_block() {
            //# finally_block: 'finally' ':' block
            let a, mark;
            mark = this.mark();
            if ((this.expect("finally")) && (this.expect(":")) && (a = this.block())) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        return_stmt() {
            //# return_stmt: 'return' star_expressions?
            let a, mark;
            mark = this.mark();
            if ((this.expect("return")) && (a = this.star_expressions() || 1)) {
                return new Return(a, ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        raise_stmt() {
            //# raise_stmt: 'raise' expression ['from' expression] | 'raise'
            let a, b, mark;
            mark = this.mark();
            if ((this.expect("raise")) && (a = this.expression()) && (b = this._tmp_50() || 1)) {
                return new Raise(a, b, ...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("raise"))) {
                return new Raise(null, null, ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        function_def() {
            //# function_def: decorators function_def_raw | function_def_raw
            let d, f, function_def_raw, mark;
            mark = this.mark();
            if ((d = this.decorators()) && (f = this.function_def_raw())) {
                return pegen.function_def_decorators(d, f);
            }
            this.reset(mark);
            if ((function_def_raw = this.function_def_raw())) {
                return function_def_raw;
            }
            this.reset(mark);
            return null;
        }
        function_def_raw() {
            //# function_def_raw: 'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block | ASYNC 'def' NAME '(' params? ')' ['->' expression] ':' func_type_comment? block
            let a, b, mark, n, params, tc;
            mark = this.mark();
            if ((this.expect("def")) &&
                (n = this.name()) &&
                (this.expect("(")) &&
                (params = this.params() || 1) &&
                (this.expect(")")) &&
                (a = this._tmp_51() || 1) &&
                (this.expect(":")) &&
                (tc = this.func_type_comment() || 1) &&
                (b = this.block())) {
                return new FunctionDef(n.id, params ? params : (arguments_ty, pegen.empty_arguments(p)), b, null, a, NEW_TYPE_COMMENT(tc), ...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("ASYNC")) &&
                (this.expect("def")) &&
                (n = this.name()) &&
                (this.expect("(")) &&
                (params = this.params() || 1) &&
                (this.expect(")")) &&
                (a = this._tmp_52() || 1) &&
                (this.expect(":")) &&
                (tc = this.func_type_comment() || 1) &&
                (b = this.block())) {
                return CHECK_VERSION(5, "Async functions are", new AsyncFunctionDef(n.id, params ? params : (arguments_ty, pegen.empty_arguments(p)), b, null, a, NEW_TYPE_COMMENT(tc), ...EXTRA));
            }
            this.reset(mark);
            return null;
        }
        func_type_comment() {
            //# func_type_comment: NEWLINE TYPE_COMMENT &(NEWLINE INDENT) | invalid_double_type_comments | TYPE_COMMENT
            let invalid_double_type_comments, mark, t, type_comment;
            mark = this.mark();
            if ((this.expect("NEWLINE")) && (t = this.expect("TYPE_COMMENT")) && this.positive_lookahead(this._tmp_53)) {
                return t;
            }
            this.reset(mark);
            if ((invalid_double_type_comments = this.invalid_double_type_comments())) {
                return invalid_double_type_comments;
            }
            this.reset(mark);
            if ((type_comment = this.expect("TYPE_COMMENT"))) {
                return type_comment;
            }
            this.reset(mark);
            return null;
        }
        params() {
            //# params: invalid_parameters | parameters
            let invalid_parameters, mark, parameters;
            mark = this.mark();
            if ((invalid_parameters = this.invalid_parameters())) {
                return invalid_parameters;
            }
            this.reset(mark);
            if ((parameters = this.parameters())) {
                return parameters;
            }
            this.reset(mark);
            return null;
        }
        parameters() {
            //# parameters: slash_no_default param_no_default* param_with_default* star_etc? | slash_with_default param_with_default* star_etc? | param_no_default+ param_with_default* star_etc? | param_with_default+ star_etc? | star_etc
            let a, b, c, d, mark;
            mark = this.mark();
            if ((a = this.slash_no_default()) && (b = this._loop0_54()) && (c = this._loop0_55()) && (d = this.star_etc() || 1)) {
                return pegen.make_arguments(a, null, b, c, d);
            }
            this.reset(mark);
            if ((a = this.slash_with_default()) && (b = this._loop0_56()) && (c = this.star_etc() || 1)) {
                return pegen.make_arguments(null, a, null, b, c);
            }
            this.reset(mark);
            if ((a = this._loop1_57()) && (b = this._loop0_58()) && (c = this.star_etc() || 1)) {
                return pegen.make_arguments(null, null, a, b, c);
            }
            this.reset(mark);
            if ((a = this._loop1_59()) && (b = this.star_etc() || 1)) {
                return pegen.make_arguments(null, null, null, a, b);
            }
            this.reset(mark);
            if ((a = this.star_etc())) {
                return pegen.make_arguments(null, null, null, null, a);
            }
            this.reset(mark);
            return null;
        }
        slash_no_default() {
            //# slash_no_default: param_no_default+ '/' ',' | param_no_default+ '/' &')'
            let a, mark;
            mark = this.mark();
            if ((a = this._loop1_60()) && (this.expect("/")) && (this.expect(","))) {
                return a;
            }
            this.reset(mark);
            if ((a = this._loop1_61()) && (this.expect("/")) && this.positive_lookahead(this.expect, ")")) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        slash_with_default() {
            //# slash_with_default: param_no_default* param_with_default+ '/' ',' | param_no_default* param_with_default+ '/' &')'
            let a, b, mark;
            mark = this.mark();
            if ((a = this._loop0_62()) && (b = this._loop1_63()) && (this.expect("/")) && (this.expect(","))) {
                return pegen.slash_with_default(a, b);
            }
            this.reset(mark);
            if ((a = this._loop0_64()) && (b = this._loop1_65()) && (this.expect("/")) && this.positive_lookahead(this.expect, ")")) {
                return pegen.slash_with_default(a, b);
            }
            this.reset(mark);
            return null;
        }
        star_etc() {
            //# star_etc: '*' param_no_default param_maybe_default* kwds? | '*' ',' param_maybe_default+ kwds? | kwds | invalid_star_etc
            let a, b, c, invalid_star_etc, mark;
            mark = this.mark();
            if ((this.expect("*")) && (a = this.param_no_default()) && (b = this._loop0_66()) && (c = this.kwds() || 1)) {
                return pegen.star_etc(a, b, c);
            }
            this.reset(mark);
            if ((this.expect("*")) && (this.expect(",")) && (b = this._loop1_67()) && (c = this.kwds() || 1)) {
                return pegen.star_etc(null, b, c);
            }
            this.reset(mark);
            if ((a = this.kwds())) {
                return pegen.star_etc(null, null, a);
            }
            this.reset(mark);
            if ((invalid_star_etc = this.invalid_star_etc())) {
                return invalid_star_etc;
            }
            this.reset(mark);
            return null;
        }
        kwds() {
            //# kwds: '**' param_no_default
            let a, mark;
            mark = this.mark();
            if ((this.expect("**")) && (a = this.param_no_default())) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        param_no_default() {
            //# param_no_default: param ',' TYPE_COMMENT? | param TYPE_COMMENT? &')'
            let a, mark, tc;
            mark = this.mark();
            if ((a = this.param()) && (this.expect(",")) && (tc = this.expect("TYPE_COMMENT") || 1)) {
                return pegen.add_type_comment_to_arg(a, tc);
            }
            this.reset(mark);
            if ((a = this.param()) && (tc = this.expect("TYPE_COMMENT") || 1) && this.positive_lookahead(this.expect, ")")) {
                return pegen.add_type_comment_to_arg(a, tc);
            }
            this.reset(mark);
            return null;
        }
        param_with_default() {
            //# param_with_default: param default ',' TYPE_COMMENT? | param default TYPE_COMMENT? &')'
            let a, c, mark, tc;
            mark = this.mark();
            if ((a = this.param()) && (c = this.default()) && (this.expect(",")) && (tc = this.expect("TYPE_COMMENT") || 1)) {
                return pegen.name_default_pair(a, c, tc);
            }
            this.reset(mark);
            if ((a = this.param()) && (c = this.default()) && (tc = this.expect("TYPE_COMMENT") || 1) && this.positive_lookahead(this.expect, ")")) {
                return pegen.name_default_pair(a, c, tc);
            }
            this.reset(mark);
            return null;
        }
        param_maybe_default() {
            //# param_maybe_default: param default? ',' TYPE_COMMENT? | param default? TYPE_COMMENT? &')'
            let a, c, mark, tc;
            mark = this.mark();
            if ((a = this.param()) && (c = this.default() || 1) && (this.expect(",")) && (tc = this.expect("TYPE_COMMENT") || 1)) {
                return pegen.name_default_pair(a, c, tc);
            }
            this.reset(mark);
            if ((a = this.param()) && (c = this.default() || 1) && (tc = this.expect("TYPE_COMMENT") || 1) && this.positive_lookahead(this.expect, ")")) {
                return pegen.name_default_pair(a, c, tc);
            }
            this.reset(mark);
            return null;
        }
        param() {
            //# param: NAME annotation?
            let a, b, mark;
            mark = this.mark();
            if ((a = this.name()) && (b = this.annotation() || 1)) {
                return new arg(a.id, b, null, ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        annotation() {
            //# annotation: ':' expression
            let a, mark;
            mark = this.mark();
            if ((this.expect(":")) && (a = this.expression())) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        default() {
            //# default: '=' expression
            let a, mark;
            mark = this.mark();
            if ((this.expect("=")) && (a = this.expression())) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        decorators() {
            //# decorators: (('@' named_expression NEWLINE))+
            let a, mark;
            mark = this.mark();
            if ((a = this._loop1_68())) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        class_def() {
            //# class_def: decorators class_def_raw | class_def_raw
            let a, b, class_def_raw, mark;
            mark = this.mark();
            if ((a = this.decorators()) && (b = this.class_def_raw())) {
                return pegen.class_def_decorators(a, b);
            }
            this.reset(mark);
            if ((class_def_raw = this.class_def_raw())) {
                return class_def_raw;
            }
            this.reset(mark);
            return null;
        }
        class_def_raw() {
            //# class_def_raw: 'class' NAME ['(' arguments? ')'] ':' block
            let a, b, c, mark;
            mark = this.mark();
            if ((this.expect("class")) && (a = this.name()) && (b = this._tmp_69() || 1) && (this.expect(":")) && (c = this.block())) {
                return new ClassDef(a.id, b.args, b.keywords, c, null, ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        block() {
            //# block: NEWLINE INDENT statements DEDENT | simple_stmts | invalid_block
            let a, invalid_block, mark, simple_stmts;
            mark = this.mark();
            if ((this.expect("NEWLINE")) && (this.expect("INDENT")) && (a = this.statements()) && (this.expect("DEDENT"))) {
                return a;
            }
            this.reset(mark);
            if ((simple_stmts = this.simple_stmts())) {
                return simple_stmts;
            }
            this.reset(mark);
            if ((invalid_block = this.invalid_block())) {
                return invalid_block;
            }
            this.reset(mark);
            return null;
        }
        star_expressions() {
            //# star_expressions: star_expression ((',' star_expression))+ ','? | star_expression ',' | star_expression
            let a, b, mark, star_expression;
            mark = this.mark();
            if ((a = this.star_expression()) && (b = this._loop1_70()) && (this.expect(",") || 1)) {
                return new Tuple(pegen.seq_insert_in_front(a, b), new Load(), ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.star_expression()) && (this.expect(","))) {
                return new Tuple(pegen.singleton_seq(a), new Load(), ...EXTRA);
            }
            this.reset(mark);
            if ((star_expression = this.star_expression())) {
                return star_expression;
            }
            this.reset(mark);
            return null;
        }
        star_expression() {
            //# star_expression: '*' bitwise_or | expression
            let a, expression, mark;
            mark = this.mark();
            if ((this.expect("*")) && (a = this.bitwise_or())) {
                return new Starred(a, new Load(), ...EXTRA);
            }
            this.reset(mark);
            if ((expression = this.expression())) {
                return expression;
            }
            this.reset(mark);
            return null;
        }
        star_named_expressions() {
            //# star_named_expressions: ','.star_named_expression+ ','?
            let a, mark;
            mark = this.mark();
            if ((a = this._gather_71()) && (this.expect(",") || 1)) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        star_named_expression() {
            //# star_named_expression: '*' bitwise_or | named_expression
            let a, mark, named_expression;
            mark = this.mark();
            if ((this.expect("*")) && (a = this.bitwise_or())) {
                return new Starred(a, new Load(), ...EXTRA);
            }
            this.reset(mark);
            if ((named_expression = this.named_expression())) {
                return named_expression;
            }
            this.reset(mark);
            return null;
        }
        named_expression() {
            //# named_expression: NAME ':=' ~ expression | expression !':=' | invalid_named_expression
            let a, b, cut, expression, invalid_named_expression, mark;
            mark = this.mark();
            if ((a = this.name()) && (this.expect(":=")) && (cut = true) && (b = this.expression())) {
                return new NamedExpr(pegen.set_expr_context(a, new Store()), b, ...EXTRA);
            }
            this.reset(mark);
            if (cut)
                return null;
            cut = false;
            if ((expression = this.expression()) && this.negative_lookahead(this.expect, ":=")) {
                return expression;
            }
            this.reset(mark);
            if ((invalid_named_expression = this.invalid_named_expression())) {
                return invalid_named_expression;
            }
            this.reset(mark);
            return null;
        }
        annotated_rhs() {
            //# annotated_rhs: yield_expr | star_expressions
            let mark, star_expressions, yield_expr;
            mark = this.mark();
            if ((yield_expr = this.yield_expr())) {
                return yield_expr;
            }
            this.reset(mark);
            if ((star_expressions = this.star_expressions())) {
                return star_expressions;
            }
            this.reset(mark);
            return null;
        }
        expressions() {
            //# expressions: expression ((',' expression))+ ','? | expression ',' | expression
            let a, b, expression, mark;
            mark = this.mark();
            if ((a = this.expression()) && (b = this._loop1_73()) && (this.expect(",") || 1)) {
                return new Tuple(pegen.seq_insert_in_front(a, b), new Load(), ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.expression()) && (this.expect(","))) {
                return new Tuple(pegen.singleton_seq(a), new Load(), ...EXTRA);
            }
            this.reset(mark);
            if ((expression = this.expression())) {
                return expression;
            }
            this.reset(mark);
            return null;
        }
        expression() {
            //# expression: disjunction 'if' disjunction 'else' expression | disjunction | lambdef
            let a, b, c, disjunction, lambdef, mark;
            mark = this.mark();
            if ((a = this.disjunction()) && (this.expect("if")) && (b = this.disjunction()) && (this.expect("else")) && (c = this.expression())) {
                return new IfExp(b, a, c, ...EXTRA);
            }
            this.reset(mark);
            if ((disjunction = this.disjunction())) {
                return disjunction;
            }
            this.reset(mark);
            if ((lambdef = this.lambdef())) {
                return lambdef;
            }
            this.reset(mark);
            return null;
        }
        lambdef() {
            //# lambdef: 'lambda' lambda_params? ':' expression
            let a, b, mark;
            mark = this.mark();
            if ((this.expect("lambda")) && (a = this.lambda_params() || 1) && (this.expect(":")) && (b = this.expression())) {
                return new Lambda(a ? a : (arguments_ty, pegen.empty_arguments(p)), b, ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        lambda_params() {
            //# lambda_params: invalid_lambda_parameters | lambda_parameters
            let invalid_lambda_parameters, lambda_parameters, mark;
            mark = this.mark();
            if ((invalid_lambda_parameters = this.invalid_lambda_parameters())) {
                return invalid_lambda_parameters;
            }
            this.reset(mark);
            if ((lambda_parameters = this.lambda_parameters())) {
                return lambda_parameters;
            }
            this.reset(mark);
            return null;
        }
        lambda_parameters() {
            //# lambda_parameters: lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc? | lambda_slash_with_default lambda_param_with_default* lambda_star_etc? | lambda_param_no_default+ lambda_param_with_default* lambda_star_etc? | lambda_param_with_default+ lambda_star_etc? | lambda_star_etc
            let a, b, c, d, mark;
            mark = this.mark();
            if ((a = this.lambda_slash_no_default()) && (b = this._loop0_74()) && (c = this._loop0_75()) && (d = this.lambda_star_etc() || 1)) {
                return pegen.make_arguments(a, null, b, c, d);
            }
            this.reset(mark);
            if ((a = this.lambda_slash_with_default()) && (b = this._loop0_76()) && (c = this.lambda_star_etc() || 1)) {
                return pegen.make_arguments(null, a, null, b, c);
            }
            this.reset(mark);
            if ((a = this._loop1_77()) && (b = this._loop0_78()) && (c = this.lambda_star_etc() || 1)) {
                return pegen.make_arguments(null, null, a, b, c);
            }
            this.reset(mark);
            if ((a = this._loop1_79()) && (b = this.lambda_star_etc() || 1)) {
                return pegen.make_arguments(null, null, null, a, b);
            }
            this.reset(mark);
            if ((a = this.lambda_star_etc())) {
                return pegen.make_arguments(null, null, null, null, a);
            }
            this.reset(mark);
            return null;
        }
        lambda_slash_no_default() {
            //# lambda_slash_no_default: lambda_param_no_default+ '/' ',' | lambda_param_no_default+ '/' &':'
            let a, mark;
            mark = this.mark();
            if ((a = this._loop1_80()) && (this.expect("/")) && (this.expect(","))) {
                return a;
            }
            this.reset(mark);
            if ((a = this._loop1_81()) && (this.expect("/")) && this.positive_lookahead(this.expect, ":")) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        lambda_slash_with_default() {
            //# lambda_slash_with_default: lambda_param_no_default* lambda_param_with_default+ '/' ',' | lambda_param_no_default* lambda_param_with_default+ '/' &':'
            let a, b, mark;
            mark = this.mark();
            if ((a = this._loop0_82()) && (b = this._loop1_83()) && (this.expect("/")) && (this.expect(","))) {
                return pegen.slash_with_default(a, b);
            }
            this.reset(mark);
            if ((a = this._loop0_84()) && (b = this._loop1_85()) && (this.expect("/")) && this.positive_lookahead(this.expect, ":")) {
                return pegen.slash_with_default(a, b);
            }
            this.reset(mark);
            return null;
        }
        lambda_star_etc() {
            //# lambda_star_etc: '*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds? | '*' ',' lambda_param_maybe_default+ lambda_kwds? | lambda_kwds | invalid_lambda_star_etc
            let a, b, c, invalid_lambda_star_etc, mark;
            mark = this.mark();
            if ((this.expect("*")) && (a = this.lambda_param_no_default()) && (b = this._loop0_86()) && (c = this.lambda_kwds() || 1)) {
                return pegen.star_etc(a, b, c);
            }
            this.reset(mark);
            if ((this.expect("*")) && (this.expect(",")) && (b = this._loop1_87()) && (c = this.lambda_kwds() || 1)) {
                return pegen.star_etc(null, b, c);
            }
            this.reset(mark);
            if ((a = this.lambda_kwds())) {
                return pegen.star_etc(null, null, a);
            }
            this.reset(mark);
            if ((invalid_lambda_star_etc = this.invalid_lambda_star_etc())) {
                return invalid_lambda_star_etc;
            }
            this.reset(mark);
            return null;
        }
        lambda_kwds() {
            //# lambda_kwds: '**' lambda_param_no_default
            let a, mark;
            mark = this.mark();
            if ((this.expect("**")) && (a = this.lambda_param_no_default())) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        lambda_param_no_default() {
            //# lambda_param_no_default: lambda_param ',' | lambda_param &':'
            let a, mark;
            mark = this.mark();
            if ((a = this.lambda_param()) && (this.expect(","))) {
                return a;
            }
            this.reset(mark);
            if ((a = this.lambda_param()) && this.positive_lookahead(this.expect, ":")) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        lambda_param_with_default() {
            //# lambda_param_with_default: lambda_param default ',' | lambda_param default &':'
            let a, c, mark;
            mark = this.mark();
            if ((a = this.lambda_param()) && (c = this.default()) && (this.expect(","))) {
                return pegen.name_default_pair(a, c, null);
            }
            this.reset(mark);
            if ((a = this.lambda_param()) && (c = this.default()) && this.positive_lookahead(this.expect, ":")) {
                return pegen.name_default_pair(a, c, null);
            }
            this.reset(mark);
            return null;
        }
        lambda_param_maybe_default() {
            //# lambda_param_maybe_default: lambda_param default? ',' | lambda_param default? &':'
            let a, c, mark;
            mark = this.mark();
            if ((a = this.lambda_param()) && (c = this.default() || 1) && (this.expect(","))) {
                return pegen.name_default_pair(a, c, null);
            }
            this.reset(mark);
            debugger;
            if ((a = this.lambda_param()) && (c = this.default() || 1) && this.positive_lookahead(this.expect, ":")) {
                return pegen.name_default_pair(a, c, null);
            }
            this.reset(mark);
            return null;
        }
        lambda_param() {
            //# lambda_param: NAME
            let a, mark;
            mark = this.mark();
            if ((a = this.name())) {
                return new arg(a.id, null, null, ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        disjunction() {
            //# disjunction: conjunction (('or' conjunction))+ | conjunction
            let a, b, conjunction, mark;
            mark = this.mark();
            if ((a = this.conjunction()) && (b = this._loop1_88())) {
                return new BoolOp(new Or(), pegen.seq_insert_in_front(a, b), ...EXTRA);
            }
            this.reset(mark);
            if ((conjunction = this.conjunction())) {
                return conjunction;
            }
            this.reset(mark);
            return null;
        }
        conjunction() {
            //# conjunction: inversion (('and' inversion))+ | inversion
            let a, b, inversion, mark;
            mark = this.mark();
            if ((a = this.inversion()) && (b = this._loop1_89())) {
                return new BoolOp(new And(), pegen.seq_insert_in_front(a, b), ...EXTRA);
            }
            this.reset(mark);
            if ((inversion = this.inversion())) {
                return inversion;
            }
            this.reset(mark);
            return null;
        }
        inversion() {
            //# inversion: 'not' inversion | comparison
            let a, comparison, mark;
            mark = this.mark();
            if ((this.expect("not")) && (a = this.inversion())) {
                return new UnaryOp(new Not(), a, ...EXTRA);
            }
            this.reset(mark);
            if ((comparison = this.comparison())) {
                return comparison;
            }
            this.reset(mark);
            return null;
        }
        comparison() {
            //# comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or
            let a, b, bitwise_or, mark;
            mark = this.mark();
            if ((a = this.bitwise_or()) && (b = this._loop1_90())) {
                return new Compare(a, pegen.get_cmpops(b), pegen.get_exprs(b), ...EXTRA);
            }
            this.reset(mark);
            if ((bitwise_or = this.bitwise_or())) {
                return bitwise_or;
            }
            this.reset(mark);
            return null;
        }
        compare_op_bitwise_or_pair() {
            //# compare_op_bitwise_or_pair: eq_bitwise_or | noteq_bitwise_or | lte_bitwise_or | lt_bitwise_or | gte_bitwise_or | gt_bitwise_or | notin_bitwise_or | in_bitwise_or | isnot_bitwise_or | is_bitwise_or
            let eq_bitwise_or, gt_bitwise_or, gte_bitwise_or, in_bitwise_or, is_bitwise_or, isnot_bitwise_or, lt_bitwise_or, lte_bitwise_or, mark, noteq_bitwise_or, notin_bitwise_or;
            mark = this.mark();
            if ((eq_bitwise_or = this.eq_bitwise_or())) {
                return eq_bitwise_or;
            }
            this.reset(mark);
            if ((noteq_bitwise_or = this.noteq_bitwise_or())) {
                return noteq_bitwise_or;
            }
            this.reset(mark);
            if ((lte_bitwise_or = this.lte_bitwise_or())) {
                return lte_bitwise_or;
            }
            this.reset(mark);
            if ((lt_bitwise_or = this.lt_bitwise_or())) {
                return lt_bitwise_or;
            }
            this.reset(mark);
            if ((gte_bitwise_or = this.gte_bitwise_or())) {
                return gte_bitwise_or;
            }
            this.reset(mark);
            if ((gt_bitwise_or = this.gt_bitwise_or())) {
                return gt_bitwise_or;
            }
            this.reset(mark);
            if ((notin_bitwise_or = this.notin_bitwise_or())) {
                return notin_bitwise_or;
            }
            this.reset(mark);
            if ((in_bitwise_or = this.in_bitwise_or())) {
                return in_bitwise_or;
            }
            this.reset(mark);
            if ((isnot_bitwise_or = this.isnot_bitwise_or())) {
                return isnot_bitwise_or;
            }
            this.reset(mark);
            if ((is_bitwise_or = this.is_bitwise_or())) {
                return is_bitwise_or;
            }
            this.reset(mark);
            return null;
        }
        eq_bitwise_or() {
            //# eq_bitwise_or: '==' bitwise_or
            let a, mark;
            mark = this.mark();
            if ((this.expect("==")) && (a = this.bitwise_or())) {
                return pegen.cmpop_expr_pair(new Eq(), a);
            }
            this.reset(mark);
            return null;
        }
        noteq_bitwise_or() {
            //# noteq_bitwise_or: ('!=') bitwise_or
            let a, mark;
            mark = this.mark();
            if ((this.expect("!=")) && (a = this.bitwise_or())) {
                return pegen.cmpop_expr_pair(new NotEq(), a);
            }
            this.reset(mark);
            return null;
        }
        lte_bitwise_or() {
            //# lte_bitwise_or: '<=' bitwise_or
            let a, mark;
            mark = this.mark();
            if ((this.expect("<=")) && (a = this.bitwise_or())) {
                return pegen.cmpop_expr_pair(new LtE(), a);
            }
            this.reset(mark);
            return null;
        }
        lt_bitwise_or() {
            //# lt_bitwise_or: '<' bitwise_or
            let a, mark;
            mark = this.mark();
            if ((this.expect("<")) && (a = this.bitwise_or())) {
                return pegen.cmpop_expr_pair(new Lt(), a);
            }
            this.reset(mark);
            return null;
        }
        gte_bitwise_or() {
            //# gte_bitwise_or: '>=' bitwise_or
            let a, mark;
            mark = this.mark();
            if ((this.expect(">=")) && (a = this.bitwise_or())) {
                return pegen.cmpop_expr_pair(new GtE(), a);
            }
            this.reset(mark);
            return null;
        }
        gt_bitwise_or() {
            //# gt_bitwise_or: '>' bitwise_or
            let a, mark;
            mark = this.mark();
            if ((this.expect(">")) && (a = this.bitwise_or())) {
                return pegen.cmpop_expr_pair(new Gt(), a);
            }
            this.reset(mark);
            return null;
        }
        notin_bitwise_or() {
            //# notin_bitwise_or: 'not' 'in' bitwise_or
            let a, mark;
            mark = this.mark();
            if ((this.expect("not")) && (this.expect("in")) && (a = this.bitwise_or())) {
                return pegen.cmpop_expr_pair(new NotIn(), a);
            }
            this.reset(mark);
            return null;
        }
        in_bitwise_or() {
            //# in_bitwise_or: 'in' bitwise_or
            let a, mark;
            mark = this.mark();
            if ((this.expect("in")) && (a = this.bitwise_or())) {
                return pegen.cmpop_expr_pair(new In(), a);
            }
            this.reset(mark);
            return null;
        }
        isnot_bitwise_or() {
            //# isnot_bitwise_or: 'is' 'not' bitwise_or
            let a, mark;
            mark = this.mark();
            if ((this.expect("is")) && (this.expect("not")) && (a = this.bitwise_or())) {
                return pegen.cmpop_expr_pair(new IsNot(), a);
            }
            this.reset(mark);
            return null;
        }
        is_bitwise_or() {
            //# is_bitwise_or: 'is' bitwise_or
            let a, mark;
            mark = this.mark();
            if ((this.expect("is")) && (a = this.bitwise_or())) {
                return pegen.cmpop_expr_pair(new Is(), a);
            }
            this.reset(mark);
            return null;
        }
        bitwise_or() {
            //# bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor
            let a, b, bitwise_xor, mark;
            mark = this.mark();
            if ((a = this.bitwise_or()) && (this.expect("|")) && (b = this.bitwise_xor())) {
                return new BinOp(a, new BitOr(), b, ...EXTRA);
            }
            this.reset(mark);
            if ((bitwise_xor = this.bitwise_xor())) {
                return bitwise_xor;
            }
            this.reset(mark);
            return null;
        }
        bitwise_xor() {
            //# bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and
            let a, b, bitwise_and, mark;
            mark = this.mark();
            if ((a = this.bitwise_xor()) && (this.expect("^")) && (b = this.bitwise_and())) {
                return new BinOp(a, new BitXor(), b, ...EXTRA);
            }
            this.reset(mark);
            if ((bitwise_and = this.bitwise_and())) {
                return bitwise_and;
            }
            this.reset(mark);
            return null;
        }
        bitwise_and() {
            //# bitwise_and: bitwise_and '&' shift_expr | shift_expr
            let a, b, mark, shift_expr;
            mark = this.mark();
            if ((a = this.bitwise_and()) && (this.expect("&")) && (b = this.shift_expr())) {
                return new BinOp(a, new BitAnd(), b, ...EXTRA);
            }
            this.reset(mark);
            if ((shift_expr = this.shift_expr())) {
                return shift_expr;
            }
            this.reset(mark);
            return null;
        }
        shift_expr() {
            //# shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum
            let a, b, mark, sum;
            mark = this.mark();
            if ((a = this.shift_expr()) && (this.expect("<<")) && (b = this.sum())) {
                return new BinOp(a, new LShift(), b, ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.shift_expr()) && (this.expect(">>")) && (b = this.sum())) {
                return new BinOp(a, new RShift(), b, ...EXTRA);
            }
            this.reset(mark);
            if ((sum = this.sum())) {
                return sum;
            }
            this.reset(mark);
            return null;
        }
        sum() {
            //# sum: sum '+' term | sum '-' term | term
            let a, b, mark, term;
            mark = this.mark();
            if ((a = this.sum()) && (this.expect("+")) && (b = this.term())) {
                return new BinOp(a, new Add(), b, ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.sum()) && (this.expect("-")) && (b = this.term())) {
                return new BinOp(a, new Sub(), b, ...EXTRA);
            }
            this.reset(mark);
            if ((term = this.term())) {
                return term;
            }
            this.reset(mark);
            return null;
        }
        term() {
            //# term: term '*' factor | term '/' factor | term '//' factor | term '%' factor | term '@' factor | factor
            let a, b, factor, mark;
            mark = this.mark();
            if ((a = this.term()) && (this.expect("*")) && (b = this.factor())) {
                return new BinOp(a, new Mult(), b, ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.term()) && (this.expect("/")) && (b = this.factor())) {
                return new BinOp(a, new Div(), b, ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.term()) && (this.expect("//")) && (b = this.factor())) {
                return new BinOp(a, new FloorDiv(), b, ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.term()) && (this.expect("%")) && (b = this.factor())) {
                return new BinOp(a, new Mod(), b, ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.term()) && (this.expect("@")) && (b = this.factor())) {
                return CHECK_VERSION(5, "The '@' operator is", new BinOp(a, new MatMult(), b, ...EXTRA));
            }
            this.reset(mark);
            if ((factor = this.factor())) {
                return factor;
            }
            this.reset(mark);
            return null;
        }
        factor() {
            //# factor: '+' factor | '-' factor | '~' factor | power
            let a, mark, power;
            mark = this.mark();
            if ((this.expect("+")) && (a = this.factor())) {
                return new UnaryOp(new UAdd(), a, ...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("-")) && (a = this.factor())) {
                return new UnaryOp(new USub(), a, ...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("~")) && (a = this.factor())) {
                return new UnaryOp(new Invert(), a, ...EXTRA);
            }
            this.reset(mark);
            if ((power = this.power())) {
                return power;
            }
            this.reset(mark);
            return null;
        }
        power() {
            //# power: await_primary '**' factor | await_primary
            let a, await_primary, b, mark;
            mark = this.mark();
            if ((a = this.await_primary()) && (this.expect("**")) && (b = this.factor())) {
                return new BinOp(a, new Pow(), b, ...EXTRA);
            }
            this.reset(mark);
            if ((await_primary = this.await_primary())) {
                return await_primary;
            }
            this.reset(mark);
            return null;
        }
        await_primary() {
            //# await_primary: AWAIT primary | primary
            let a, mark, primary;
            mark = this.mark();
            if ((this.expect("AWAIT")) && (a = this.primary())) {
                return CHECK_VERSION(5, "Await expressions are", new Await(a, ...EXTRA));
            }
            this.reset(mark);
            if ((primary = this.primary())) {
                return primary;
            }
            this.reset(mark);
            return null;
        }
        primary() {
            //# primary: invalid_primary | primary '.' NAME | primary genexp | primary '(' arguments? ')' | primary '[' slices ']' | atom
            let a, atom, b, invalid_primary, mark;
            mark = this.mark();
            if ((invalid_primary = this.invalid_primary())) {
                return invalid_primary;
            }
            this.reset(mark);
            if ((a = this.primary()) && (this.expect(".")) && (b = this.name())) {
                return new Attribute(a, b.id, new Load(), ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.primary()) && (b = this.genexp())) {
                return new Call(a, pegen.singleton_seq(b), null, ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.primary()) && (this.expect("(")) && (b = this.arguments() || 1) && (this.expect(")"))) {
                return new Call(a, b.args, b.keywords, ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.primary()) && (this.expect("[")) && (b = this.slices()) && (this.expect("]"))) {
                return new Subscript(a, b, new Load(), ...EXTRA);
            }
            this.reset(mark);
            if ((atom = this.atom())) {
                return atom;
            }
            this.reset(mark);
            return null;
        }
        slices() {
            //# slices: slice !',' | ','.slice+ ','?
            let a, mark;
            mark = this.mark();
            if ((a = this.slice()) && this.negative_lookahead(this.expect, ",")) {
                return a;
            }
            this.reset(mark);
            if ((a = this._gather_91()) && (this.expect(",") || 1)) {
                return new Tuple(a, new Load(), ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        slice() {
            //# slice: expression? ':' expression? [':' expression?] | named_expression
            let a, b, c, mark;
            mark = this.mark();
            if ((a = this.expression() || 1) && (this.expect(":")) && (b = this.expression() || 1) && (c = this._tmp_93() || 1)) {
                return new Slice(a, b, c, ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.named_expression())) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        atom() {
            //# atom: NAME | 'True' | 'False' | 'None' | &STRING strings | NUMBER | &'(' (tuple | group | genexp) | &'[' (list | listcomp) | &'{' (dict | set | dictcomp | setcomp) | '...'
            let _tmp_94, _tmp_95, _tmp_96, mark, name, number, strings;
            mark = this.mark();
            if ((name = this.name())) {
                return name;
            }
            this.reset(mark);
            if ((this.expect("True"))) {
                return new Constant(pyTrue, null, ...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("False"))) {
                return new Constant(pyFalse, null, ...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("None"))) {
                return new Constant(pyNone, null, ...EXTRA);
            }
            this.reset(mark);
            if (this.positive_lookahead(this.string) && (strings = this.strings())) {
                return strings;
            }
            this.reset(mark);
            if ((number = this.number())) {
                return number;
            }
            this.reset(mark);
            if (this.positive_lookahead(this.expect, "(") && (_tmp_94 = this._tmp_94())) {
                return _tmp_94;
            }
            this.reset(mark);
            if (this.positive_lookahead(this.expect, "[") && (_tmp_95 = this._tmp_95())) {
                return _tmp_95;
            }
            this.reset(mark);
            if (this.positive_lookahead(this.expect, "{") && (_tmp_96 = this._tmp_96())) {
                return _tmp_96;
            }
            this.reset(mark);
            if ((this.expect("..."))) {
                return new Constant(pyEllipsis, null, ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        strings() {
            //# strings: STRING+
            let a, mark;
            mark = this.mark();
            if ((a = this._loop1_97())) {
                return pegen.concatenate_strings(a);
            }
            this.reset(mark);
            return null;
        }
        list() {
            //# list: '[' star_named_expressions? ']'
            let a, mark;
            mark = this.mark();
            if ((this.expect("[")) && (a = this.star_named_expressions() || 1) && (this.expect("]"))) {
                return new List(a, new Load(), ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        listcomp() {
            //# listcomp: '[' named_expression ~ for_if_clauses ']' | invalid_comprehension
            let a, b, cut, invalid_comprehension, mark;
            mark = this.mark();
            if ((this.expect("[")) && (a = this.named_expression()) && (cut = true) && (b = this.for_if_clauses()) && (this.expect("]"))) {
                return new ListComp(a, b, ...EXTRA);
            }
            this.reset(mark);
            if (cut)
                return null;
            cut = false;
            if ((invalid_comprehension = this.invalid_comprehension())) {
                return invalid_comprehension;
            }
            this.reset(mark);
            return null;
        }
        tuple() {
            //# tuple: '(' [star_named_expression ',' star_named_expressions?] ')'
            let a, mark;
            mark = this.mark();
            if ((this.expect("(")) && (a = this._tmp_98() || 1) && (this.expect(")"))) {
                return new Tuple(a, new Load(), ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        group() {
            //# group: '(' (yield_expr | named_expression) ')' | invalid_group
            let a, invalid_group, mark;
            mark = this.mark();
            if ((this.expect("(")) && (a = this._tmp_99()) && (this.expect(")"))) {
                return a;
            }
            this.reset(mark);
            if ((invalid_group = this.invalid_group())) {
                return invalid_group;
            }
            this.reset(mark);
            return null;
        }
        genexp() {
            //# genexp: '(' named_expression ~ for_if_clauses ')' | invalid_comprehension
            let a, b, cut, invalid_comprehension, mark;
            mark = this.mark();
            if ((this.expect("(")) && (a = this.named_expression()) && (cut = true) && (b = this.for_if_clauses()) && (this.expect(")"))) {
                return new GeneratorExp(a, b, ...EXTRA);
            }
            this.reset(mark);
            if (cut)
                return null;
            cut = false;
            if ((invalid_comprehension = this.invalid_comprehension())) {
                return invalid_comprehension;
            }
            this.reset(mark);
            return null;
        }
        set() {
            //# set: '{' star_named_expressions '}'
            let a, mark;
            mark = this.mark();
            if ((this.expect("{")) && (a = this.star_named_expressions()) && (this.expect("}"))) {
                return new Set$1(a, ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        setcomp() {
            //# setcomp: '{' named_expression ~ for_if_clauses '}' | invalid_comprehension
            let a, b, cut, invalid_comprehension, mark;
            mark = this.mark();
            if ((this.expect("{")) && (a = this.named_expression()) && (cut = true) && (b = this.for_if_clauses()) && (this.expect("}"))) {
                return new SetComp(a, b, ...EXTRA);
            }
            this.reset(mark);
            if (cut)
                return null;
            cut = false;
            if ((invalid_comprehension = this.invalid_comprehension())) {
                return invalid_comprehension;
            }
            this.reset(mark);
            return null;
        }
        dict() {
            //# dict: '{' double_starred_kvpairs? '}'
            let a, mark;
            mark = this.mark();
            if ((this.expect("{")) && (a = this.double_starred_kvpairs() || 1) && (this.expect("}"))) {
                return new Dict(pegen.get_keys(a), pegen.get_values(a), ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        dictcomp() {
            //# dictcomp: '{' kvpair for_if_clauses '}' | invalid_dict_comprehension
            let a, b, invalid_dict_comprehension, mark;
            mark = this.mark();
            if ((this.expect("{")) && (a = this.kvpair()) && (b = this.for_if_clauses()) && (this.expect("}"))) {
                return new DictComp(a.key, a.value, b, ...EXTRA);
            }
            this.reset(mark);
            if ((invalid_dict_comprehension = this.invalid_dict_comprehension())) {
                return invalid_dict_comprehension;
            }
            this.reset(mark);
            return null;
        }
        double_starred_kvpairs() {
            //# double_starred_kvpairs: ','.double_starred_kvpair+ ','?
            let a, mark;
            mark = this.mark();
            if ((a = this._gather_100()) && (this.expect(",") || 1)) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        double_starred_kvpair() {
            //# double_starred_kvpair: '**' bitwise_or | kvpair
            let a, kvpair, mark;
            mark = this.mark();
            if ((this.expect("**")) && (a = this.bitwise_or())) {
                return pegen.key_value_pair(null, a);
            }
            this.reset(mark);
            if ((kvpair = this.kvpair())) {
                return kvpair;
            }
            this.reset(mark);
            return null;
        }
        kvpair() {
            //# kvpair: expression ':' expression
            let a, b, mark;
            mark = this.mark();
            if ((a = this.expression()) && (this.expect(":")) && (b = this.expression())) {
                return pegen.key_value_pair(a, b);
            }
            this.reset(mark);
            return null;
        }
        for_if_clauses() {
            //# for_if_clauses: for_if_clause+
            let a, mark;
            mark = this.mark();
            if ((a = this._loop1_102())) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        for_if_clause() {
            //# for_if_clause: ASYNC 'for' star_targets 'in' ~ disjunction (('if' disjunction))* | 'for' star_targets 'in' ~ disjunction (('if' disjunction))* | invalid_for_target
            let a, b, c, cut, invalid_for_target, mark;
            mark = this.mark();
            if ((this.expect("ASYNC")) &&
                (this.expect("for")) &&
                (a = this.star_targets()) &&
                (this.expect("in")) &&
                (cut = true) &&
                (b = this.disjunction()) &&
                (c = this._loop0_103())) {
                return CHECK_VERSION(comprehension_ty, 6, "Async comprehensions are", new comprehension(a, b, c, 1));
            }
            this.reset(mark);
            if (cut)
                return null;
            cut = false;
            if ((this.expect("for")) && (a = this.star_targets()) && (this.expect("in")) && (cut = true) && (b = this.disjunction()) && (c = this._loop0_104())) {
                return new comprehension(a, b, c, 0);
            }
            this.reset(mark);
            if (cut)
                return null;
            cut = false;
            if ((invalid_for_target = this.invalid_for_target())) {
                return invalid_for_target;
            }
            this.reset(mark);
            return null;
        }
        yield_expr() {
            //# yield_expr: 'yield' 'from' expression | 'yield' star_expressions?
            let a, mark;
            mark = this.mark();
            if ((this.expect("yield")) && (this.expect("from")) && (a = this.expression())) {
                return new YieldFrom(a, ...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("yield")) && (a = this.star_expressions() || 1)) {
                return new Yield(a, ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        arguments() {
            //# arguments: args ','? &')' | invalid_arguments
            let a, invalid_arguments, mark;
            mark = this.mark();
            if ((a = this.args()) && (this.expect(",") || 1) && this.positive_lookahead(this.expect, ")")) {
                return a;
            }
            this.reset(mark);
            if ((invalid_arguments = this.invalid_arguments())) {
                return invalid_arguments;
            }
            this.reset(mark);
            return null;
        }
        args() {
            //# args: ','.(starred_expression | named_expression !'=')+ [',' kwargs] | kwargs
            let a, b, mark;
            mark = this.mark();
            if ((a = this._gather_105()) && (b = this._tmp_107() || 1)) {
                return pegen.collect_call_seqs(a, b, ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.kwargs())) {
                return new Call(pegen.dummy_name(p), CHECK_null_ALLOWED(pegen.seq_extract_starred_exprs(a)), CHECK_null_ALLOWED(pegen.seq_delete_starred_exprs(a)), ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        kwargs() {
            //# kwargs: ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+ | ','.kwarg_or_starred+ | ','.kwarg_or_double_starred+
            let _gather_112, _gather_114, a, b, mark;
            mark = this.mark();
            if ((a = this._gather_108()) && (this.expect(",")) && (b = this._gather_110())) {
                return pegen.join_sequences(a, b);
            }
            this.reset(mark);
            if ((_gather_112 = this._gather_112())) {
                return _gather_112;
            }
            this.reset(mark);
            if ((_gather_114 = this._gather_114())) {
                return _gather_114;
            }
            this.reset(mark);
            return null;
        }
        starred_expression() {
            //# starred_expression: '*' expression
            let a, mark;
            mark = this.mark();
            if ((this.expect("*")) && (a = this.expression())) {
                return new Starred(a, new Load(), ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        kwarg_or_starred() {
            //# kwarg_or_starred: NAME '=' expression | starred_expression | invalid_kwarg
            let a, b, invalid_kwarg, mark;
            mark = this.mark();
            if ((a = this.name()) && (this.expect("=")) && (b = this.expression())) {
                return pegen.keyword_or_starred((keyword_ty, new keyword(a.id, b, ...EXTRA)), 1);
            }
            this.reset(mark);
            if ((a = this.starred_expression())) {
                return pegen.keyword_or_starred(a, 0);
            }
            this.reset(mark);
            if ((invalid_kwarg = this.invalid_kwarg())) {
                return invalid_kwarg;
            }
            this.reset(mark);
            return null;
        }
        kwarg_or_double_starred() {
            //# kwarg_or_double_starred: NAME '=' expression | '**' expression | invalid_kwarg
            let a, b, invalid_kwarg, mark;
            mark = this.mark();
            if ((a = this.name()) && (this.expect("=")) && (b = this.expression())) {
                return pegen.keyword_or_starred((keyword_ty, new keyword(a.id, b, ...EXTRA)), 1);
            }
            this.reset(mark);
            if ((this.expect("**")) && (a = this.expression())) {
                return pegen.keyword_or_starred((keyword_ty, new keyword(null, a, ...EXTRA)), 1);
            }
            this.reset(mark);
            if ((invalid_kwarg = this.invalid_kwarg())) {
                return invalid_kwarg;
            }
            this.reset(mark);
            return null;
        }
        star_targets() {
            //# star_targets: star_target !',' | star_target ((',' star_target))* ','?
            let a, b, mark;
            mark = this.mark();
            if ((a = this.star_target()) && this.negative_lookahead(this.expect, ",")) {
                return a;
            }
            this.reset(mark);
            if ((a = this.star_target()) && (b = this._loop0_116()) && (this.expect(",") || 1)) {
                return new Tuple(pegen.seq_insert_in_front(a, b), new Store(), ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        star_targets_seq() {
            //# star_targets_seq: ','.star_target+ ','?
            let a, mark;
            mark = this.mark();
            if ((a = this._gather_117()) && (this.expect(",") || 1)) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        star_target() {
            //# star_target: '*' (!'*' star_target) | t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | star_atom
            let a, b, mark, star_atom;
            mark = this.mark();
            if ((this.expect("*")) && (a = this._tmp_119())) {
                return new Starred(pegen.set_expr_context(a, new Store()), new Store(), ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.t_primary()) && (this.expect(".")) && (b = this.name()) && this.negative_lookahead(this.t_lookahead)) {
                return new Attribute(a, b.id, new Store(), ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.t_primary()) && (this.expect("[")) && (b = this.slices()) && (this.expect("]")) && this.negative_lookahead(this.t_lookahead)) {
                return new Subscript(a, b, new Store(), ...EXTRA);
            }
            this.reset(mark);
            if ((star_atom = this.star_atom())) {
                return star_atom;
            }
            this.reset(mark);
            return null;
        }
        star_atom() {
            //# star_atom: NAME | '(' star_target ')' | '(' star_targets_seq? ')' | '[' star_targets_seq? ']'
            let a, mark;
            mark = this.mark();
            if ((a = this.name())) {
                return pegen.set_expr_context(a, new Store());
            }
            this.reset(mark);
            if ((this.expect("(")) && (a = this.star_target()) && (this.expect(")"))) {
                return pegen.set_expr_context(a, new Store());
            }
            this.reset(mark);
            if ((this.expect("(")) && (a = this.star_targets_seq() || 1) && (this.expect(")"))) {
                return new Tuple(a, new Store(), ...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("[")) && (a = this.star_targets_seq() || 1) && (this.expect("]"))) {
                return new List(a, new Store(), ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        single_target() {
            //# single_target: single_subscript_attribute_target | NAME | '(' single_target ')'
            let a, mark, single_subscript_attribute_target;
            mark = this.mark();
            if ((single_subscript_attribute_target = this.single_subscript_attribute_target())) {
                return single_subscript_attribute_target;
            }
            this.reset(mark);
            if ((a = this.name())) {
                return pegen.set_expr_context(a, new Store());
            }
            this.reset(mark);
            if ((this.expect("(")) && (a = this.single_target()) && (this.expect(")"))) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        single_subscript_attribute_target() {
            //# single_subscript_attribute_target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead
            let a, b, mark;
            mark = this.mark();
            if ((a = this.t_primary()) && (this.expect(".")) && (b = this.name()) && this.negative_lookahead(this.t_lookahead)) {
                return new Attribute(a, b.id, new Store(), ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.t_primary()) && (this.expect("[")) && (b = this.slices()) && (this.expect("]")) && this.negative_lookahead(this.t_lookahead)) {
                return new Subscript(a, b, new Store(), ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        del_targets() {
            //# del_targets: ','.del_target+ ','?
            let a, mark;
            mark = this.mark();
            if ((a = this._gather_120()) && (this.expect(",") || 1)) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        del_target() {
            //# del_target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | del_t_atom
            let a, b, del_t_atom, mark;
            mark = this.mark();
            if ((a = this.t_primary()) && (this.expect(".")) && (b = this.name()) && this.negative_lookahead(this.t_lookahead)) {
                return new Attribute(a, b.id, new Del(), ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.t_primary()) && (this.expect("[")) && (b = this.slices()) && (this.expect("]")) && this.negative_lookahead(this.t_lookahead)) {
                return new Subscript(a, b, new Del(), ...EXTRA);
            }
            this.reset(mark);
            if ((del_t_atom = this.del_t_atom())) {
                return del_t_atom;
            }
            this.reset(mark);
            return null;
        }
        del_t_atom() {
            //# del_t_atom: NAME | '(' del_target ')' | '(' del_targets? ')' | '[' del_targets? ']'
            let a, mark;
            mark = this.mark();
            if ((a = this.name())) {
                return pegen.set_expr_context(a, new Del());
            }
            this.reset(mark);
            if ((this.expect("(")) && (a = this.del_target()) && (this.expect(")"))) {
                return pegen.set_expr_context(a, new Del());
            }
            this.reset(mark);
            if ((this.expect("(")) && (a = this.del_targets() || 1) && (this.expect(")"))) {
                return new Tuple(a, new Del(), ...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("[")) && (a = this.del_targets() || 1) && (this.expect("]"))) {
                return new List(a, new Del(), ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        targets() {
            //# targets: ','.target+ ','?
            let a, mark;
            mark = this.mark();
            if ((a = this._gather_122()) && (this.expect(",") || 1)) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        target() {
            //# target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | t_atom
            let a, b, mark, t_atom;
            mark = this.mark();
            if ((a = this.t_primary()) && (this.expect(".")) && (b = this.name()) && this.negative_lookahead(this.t_lookahead)) {
                return new Attribute(a, b.id, new Store(), ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.t_primary()) && (this.expect("[")) && (b = this.slices()) && (this.expect("]")) && this.negative_lookahead(this.t_lookahead)) {
                return new Subscript(a, b, new Store(), ...EXTRA);
            }
            this.reset(mark);
            if ((t_atom = this.t_atom())) {
                return t_atom;
            }
            this.reset(mark);
            return null;
        }
        t_primary() {
            //# t_primary: t_primary '.' NAME &t_lookahead | t_primary '[' slices ']' &t_lookahead | t_primary genexp &t_lookahead | t_primary '(' arguments? ')' &t_lookahead | atom &t_lookahead
            let a, b, mark;
            mark = this.mark();
            if ((a = this.t_primary()) && (this.expect(".")) && (b = this.name()) && this.positive_lookahead(this.t_lookahead)) {
                return new Attribute(a, b.id, new Load(), ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.t_primary()) && (this.expect("[")) && (b = this.slices()) && (this.expect("]")) && this.positive_lookahead(this.t_lookahead)) {
                return new Subscript(a, b, new Load(), ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.t_primary()) && (b = this.genexp()) && this.positive_lookahead(this.t_lookahead)) {
                return new Call(a, pegen.singleton_seq(b), null, ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.t_primary()) && (this.expect("(")) && (b = this.arguments() || 1) && (this.expect(")")) && this.positive_lookahead(this.t_lookahead)) {
                return new Call(a, b.args, b.keywords, ...EXTRA);
            }
            this.reset(mark);
            if ((a = this.atom()) && this.positive_lookahead(this.t_lookahead)) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        t_lookahead() {
            //# t_lookahead: '(' | '[' | '.'
            let literal, mark;
            mark = this.mark();
            if ((literal = this.expect("("))) {
                return literal;
            }
            this.reset(mark);
            if ((literal = this.expect("["))) {
                return literal;
            }
            this.reset(mark);
            if ((literal = this.expect("."))) {
                return literal;
            }
            this.reset(mark);
            return null;
        }
        t_atom() {
            //# t_atom: NAME | '(' target ')' | '(' targets? ')' | '[' targets? ']'
            let a, b, mark;
            mark = this.mark();
            if ((a = this.name())) {
                return pegen.set_expr_context(a, new Store());
            }
            this.reset(mark);
            if ((this.expect("(")) && (a = this.target()) && (this.expect(")"))) {
                return pegen.set_expr_context(a, new Store());
            }
            this.reset(mark);
            if ((this.expect("(")) && (b = this.targets() || 1) && (this.expect(")"))) {
                return new Tuple(b, new Store(), ...EXTRA);
            }
            this.reset(mark);
            if ((this.expect("[")) && (b = this.targets() || 1) && (this.expect("]"))) {
                return new List(b, new Store(), ...EXTRA);
            }
            this.reset(mark);
            return null;
        }
        invalid_arguments() {
            //# invalid_arguments: args ',' '*' | expression for_if_clauses ',' [args | expression for_if_clauses] | args for_if_clauses | args ',' expression for_if_clauses | args ',' args
            let a, mark;
            mark = this.mark();
            if ((this.args()) && (this.expect(",")) && (this.expect("*"))) {
                return pegen.RAISE_SYNTAX_ERROR("iterable argument unpacking follows keyword argument unpacking");
            }
            this.reset(mark);
            if ((a = this.expression()) && (this.for_if_clauses()) && (this.expect(",")) && (this._tmp_124() || 1)) {
                return pegen.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "Generator expression must be parenthesized");
            }
            this.reset(mark);
            if ((a = this.args()) && (this.for_if_clauses())) {
                return pegen.nonparen_genexp_in_call(a);
            }
            this.reset(mark);
            if ((this.args()) && (this.expect(",")) && (a = this.expression()) && (this.for_if_clauses())) {
                return pegen.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "Generator expression must be parenthesized");
            }
            this.reset(mark);
            if ((a = this.args()) && (this.expect(",")) && (this.args())) {
                return pegen.arguments_parsing_error(a);
            }
            this.reset(mark);
            return null;
        }
        invalid_kwarg() {
            //# invalid_kwarg: expression '='
            let a, mark;
            mark = this.mark();
            if ((this.expression()) && (a = this.expect("="))) {
                return pegen.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, 'expression cannot contain assignment, perhaps you meant "=="?');
            }
            this.reset(mark);
            return null;
        }
        invalid_named_expression() {
            //# invalid_named_expression: expression ':=' expression
            let a, mark;
            mark = this.mark();
            if ((a = this.expression()) && (this.expect(":=")) && (this.expression())) {
                return pegen.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "cannot use assignment expressions with %s", pegen.get_expr_name(a));
            }
            this.reset(mark);
            return null;
        }
        invalid_assignment() {
            //# invalid_assignment: invalid_ann_assign_target ':' expression | star_named_expression ',' star_named_expressions* ':' expression | expression ':' expression | ((star_targets '='))* star_expressions '=' | ((star_targets '='))* yield_expr '=' | star_expressions augassign (yield_expr | star_expressions)
            let a, mark;
            mark = this.mark();
            if ((a = this.invalid_ann_assign_target()) && (this.expect(":")) && (this.expression())) {
                return pegen.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "only single target (not %s) can be annotated", pegen.get_expr_name(a));
            }
            this.reset(mark);
            if ((a = this.star_named_expression()) && (this.expect(",")) && (this._loop0_125()) && (this.expect(":")) && (this.expression())) {
                return pegen.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "only single target (not tuple) can be annotated");
            }
            this.reset(mark);
            if ((a = this.expression()) && (this.expect(":")) && (this.expression())) {
                return pegen.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "illegal target for annotation");
            }
            this.reset(mark);
            if ((this._loop0_126()) && (a = this.star_expressions()) && (this.expect("="))) {
                return pegen.RAISE_SYNTAX_ERROR_INVALID_TARGET(STAR_TARGETS, a);
            }
            this.reset(mark);
            if ((this._loop0_127()) && (a = this.yield_expr()) && (this.expect("="))) {
                return pegen.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "assignment to yield expression not possible");
            }
            this.reset(mark);
            if ((a = this.star_expressions()) && (this.augassign()) && (this._tmp_128())) {
                return pegen.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "'%s' is an illegal expression for augmented assignment", pegen.get_expr_name(a));
            }
            this.reset(mark);
            return null;
        }
        invalid_ann_assign_target() {
            //# invalid_ann_assign_target: list | tuple | '(' invalid_ann_assign_target ')'
            let a, list, mark, tuple;
            mark = this.mark();
            if ((list = this.list())) {
                return list;
            }
            this.reset(mark);
            if ((tuple = this.tuple())) {
                return tuple;
            }
            this.reset(mark);
            if ((this.expect("(")) && (a = this.invalid_ann_assign_target()) && (this.expect(")"))) {
                return a;
            }
            this.reset(mark);
            return null;
        }
        invalid_del_stmt() {
            //# invalid_del_stmt: 'del' star_expressions
            let a, mark;
            mark = this.mark();
            if ((this.expect("del")) && (a = this.star_expressions())) {
                return pegen.RAISE_SYNTAX_ERROR_INVALID_TARGET(DEL_TARGETS, a);
            }
            this.reset(mark);
            return null;
        }
        invalid_block() {
            //# invalid_block: NEWLINE !INDENT
            let mark;
            mark = this.mark();
            if ((this.expect("NEWLINE")) && this.negative_lookahead(this.expect, "INDENT")) {
                return pegen.RAISE_INDENTATION_ERROR("expected an indented block");
            }
            this.reset(mark);
            return null;
        }
        invalid_primary() {
            //# invalid_primary: primary '{'
            let a, mark;
            mark = this.mark();
            if ((this.primary()) && (a = this.expect("{"))) {
                return pegen.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "invalid syntax");
            }
            this.reset(mark);
            return null;
        }
        invalid_comprehension() {
            //# invalid_comprehension: ('[' | '(' | '{') starred_expression for_if_clauses
            let a, mark;
            mark = this.mark();
            if ((this._tmp_129()) && (a = this.starred_expression()) && (this.for_if_clauses())) {
                return pegen.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "iterable unpacking cannot be used in comprehension");
            }
            this.reset(mark);
            return null;
        }
        invalid_dict_comprehension() {
            //# invalid_dict_comprehension: '{' '**' bitwise_or for_if_clauses '}'
            let a, mark;
            mark = this.mark();
            if ((this.expect("{")) && (a = this.expect("**")) && (this.bitwise_or()) && (this.for_if_clauses()) && (this.expect("}"))) {
                return pegen.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "dict unpacking cannot be used in dict comprehension");
            }
            this.reset(mark);
            return null;
        }
        invalid_parameters() {
            //# invalid_parameters: param_no_default* (slash_with_default | param_with_default+) param_no_default
            let mark;
            mark = this.mark();
            if ((this._loop0_130()) && (this._tmp_131()) && (this.param_no_default())) {
                return pegen.RAISE_SYNTAX_ERROR("non-default argument follows default argument");
            }
            this.reset(mark);
            return null;
        }
        invalid_lambda_parameters() {
            //# invalid_lambda_parameters: lambda_param_no_default* (lambda_slash_with_default | lambda_param_with_default+) lambda_param_no_default
            let mark;
            mark = this.mark();
            if ((this._loop0_132()) && (this._tmp_133()) && (this.lambda_param_no_default())) {
                return pegen.RAISE_SYNTAX_ERROR("non-default argument follows default argument");
            }
            this.reset(mark);
            return null;
        }
        invalid_star_etc() {
            //# invalid_star_etc: '*' (')' | ',' (')' | '**')) | '*' ',' TYPE_COMMENT
            let mark;
            mark = this.mark();
            if ((this.expect("*")) && (this._tmp_134())) {
                return pegen.RAISE_SYNTAX_ERROR("named arguments must follow bare *");
            }
            this.reset(mark);
            if ((this.expect("*")) && (this.expect(",")) && (this.expect("TYPE_COMMENT"))) {
                return pegen.RAISE_SYNTAX_ERROR("bare * has associated type comment");
            }
            this.reset(mark);
            return null;
        }
        invalid_lambda_star_etc() {
            //# invalid_lambda_star_etc: '*' (':' | ',' (':' | '**'))
            let mark;
            mark = this.mark();
            if ((this.expect("*")) && (this._tmp_135())) {
                return pegen.RAISE_SYNTAX_ERROR("named arguments must follow bare *");
            }
            this.reset(mark);
            return null;
        }
        invalid_double_type_comments() {
            //# invalid_double_type_comments: TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT
            let mark;
            mark = this.mark();
            if ((this.expect("TYPE_COMMENT")) &&
                (this.expect("NEWLINE")) &&
                (this.expect("TYPE_COMMENT")) &&
                (this.expect("NEWLINE")) &&
                (this.expect("INDENT"))) {
                return pegen.RAISE_SYNTAX_ERROR("Cannot have two type comments on def");
            }
            this.reset(mark);
            return null;
        }
        invalid_with_item() {
            //# invalid_with_item: expression 'as' expression
            let a, mark;
            mark = this.mark();
            if ((this.expression()) && (this.expect("as")) && (a = this.expression())) {
                return pegen.RAISE_SYNTAX_ERROR_INVALID_TARGET(STAR_TARGETS, a);
            }
            this.reset(mark);
            return null;
        }
        invalid_for_target() {
            //# invalid_for_target: ASYNC? 'for' star_expressions
            let a, mark;
            mark = this.mark();
            if ((this.expect("ASYNC") || 1) && (this.expect("for")) && (a = this.star_expressions())) {
                return pegen.RAISE_SYNTAX_ERROR_INVALID_TARGET(FOR_TARGETS, a);
            }
            this.reset(mark);
            return null;
        }
        invalid_group() {
            //# invalid_group: '(' starred_expression ')'
            let a, mark;
            mark = this.mark();
            if ((this.expect("(")) && (a = this.starred_expression()) && (this.expect(")"))) {
                return pegen.RAISE_SYNTAX_ERROR_KNOWN_LOCATION(a, "can't use starred expression here");
            }
            this.reset(mark);
            return null;
        }
        invalid_import_from_targets() {
            //# invalid_import_from_targets: import_from_as_names ','
            let mark;
            mark = this.mark();
            if ((this.import_from_as_names()) && (this.expect(","))) {
                return pegen.RAISE_SYNTAX_ERROR("trailing comma not allowed without surrounding parentheses");
            }
            this.reset(mark);
            return null;
        }
        _loop0_1() {
            //# _loop0_1: NEWLINE
            let children, mark, newline;
            mark = this.mark();
            children = [];
            while ((newline = this.expect("NEWLINE"))) {
                children.push(newline);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop0_2() {
            //# _loop0_2: NEWLINE
            let children, mark, newline;
            mark = this.mark();
            children = [];
            while ((newline = this.expect("NEWLINE"))) {
                children.push(newline);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop0_4() {
            //# _loop0_4: ',' expression
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.expression())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_3() {
            //# _gather_3: expression _loop0_4
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.expression()) !== null && (seq = this._loop0_4()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _loop0_6() {
            //# _loop0_6: ',' expression
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.expression())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_5() {
            //# _gather_5: expression _loop0_6
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.expression()) !== null && (seq = this._loop0_6()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _loop0_8() {
            //# _loop0_8: ',' expression
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.expression())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_7() {
            //# _gather_7: expression _loop0_8
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.expression()) !== null && (seq = this._loop0_8()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _loop0_10() {
            //# _loop0_10: ',' expression
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.expression())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_9() {
            //# _gather_9: expression _loop0_10
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.expression()) !== null && (seq = this._loop0_10()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _loop1_11() {
            //# _loop1_11: statement
            let children, mark, statement;
            mark = this.mark();
            children = [];
            while ((statement = this.statement())) {
                children.push(statement);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop0_13() {
            //# _loop0_13: ';' simple_stmt
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(";")) && (elem = this.simple_stmt())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_12() {
            //# _gather_12: simple_stmt _loop0_13
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.simple_stmt()) !== null && (seq = this._loop0_13()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _tmp_14() {
            //# _tmp_14: 'import' | 'from'
            let literal, mark;
            mark = this.mark();
            if ((literal = this.expect("import"))) {
                return literal;
            }
            this.reset(mark);
            if ((literal = this.expect("from"))) {
                return literal;
            }
            this.reset(mark);
            return null;
        }
        _tmp_15() {
            //# _tmp_15: 'def' | '@' | ASYNC
            let async, literal, mark;
            mark = this.mark();
            if ((literal = this.expect("def"))) {
                return literal;
            }
            this.reset(mark);
            if ((literal = this.expect("@"))) {
                return literal;
            }
            this.reset(mark);
            if ((async = this.expect("ASYNC"))) {
                return async;
            }
            this.reset(mark);
            return null;
        }
        _tmp_16() {
            //# _tmp_16: 'class' | '@'
            let literal, mark;
            mark = this.mark();
            if ((literal = this.expect("class"))) {
                return literal;
            }
            this.reset(mark);
            if ((literal = this.expect("@"))) {
                return literal;
            }
            this.reset(mark);
            return null;
        }
        _tmp_17() {
            //# _tmp_17: 'with' | ASYNC
            let async, literal, mark;
            mark = this.mark();
            if ((literal = this.expect("with"))) {
                return literal;
            }
            this.reset(mark);
            if ((async = this.expect("ASYNC"))) {
                return async;
            }
            this.reset(mark);
            return null;
        }
        _tmp_18() {
            //# _tmp_18: 'for' | ASYNC
            let async, literal, mark;
            mark = this.mark();
            if ((literal = this.expect("for"))) {
                return literal;
            }
            this.reset(mark);
            if ((async = this.expect("ASYNC"))) {
                return async;
            }
            this.reset(mark);
            return null;
        }
        _tmp_19() {
            //# _tmp_19: '=' annotated_rhs
            let d, mark;
            mark = this.mark();
            if ((this.expect("=")) && (d = this.annotated_rhs())) {
                return d;
            }
            this.reset(mark);
            return null;
        }
        _tmp_20() {
            //# _tmp_20: '(' single_target ')' | single_subscript_attribute_target
            let b, mark, single_subscript_attribute_target;
            mark = this.mark();
            if ((this.expect("(")) && (b = this.single_target()) && (this.expect(")"))) {
                return b;
            }
            this.reset(mark);
            if ((single_subscript_attribute_target = this.single_subscript_attribute_target())) {
                return single_subscript_attribute_target;
            }
            this.reset(mark);
            return null;
        }
        _tmp_21() {
            //# _tmp_21: '=' annotated_rhs
            let d, mark;
            mark = this.mark();
            if ((this.expect("=")) && (d = this.annotated_rhs())) {
                return d;
            }
            this.reset(mark);
            return null;
        }
        _loop1_22() {
            //# _loop1_22: (star_targets '=')
            let _tmp_136, children, mark;
            mark = this.mark();
            children = [];
            while ((_tmp_136 = this._tmp_136())) {
                children.push(_tmp_136);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _tmp_23() {
            //# _tmp_23: yield_expr | star_expressions
            let mark, star_expressions, yield_expr;
            mark = this.mark();
            if ((yield_expr = this.yield_expr())) {
                return yield_expr;
            }
            this.reset(mark);
            if ((star_expressions = this.star_expressions())) {
                return star_expressions;
            }
            this.reset(mark);
            return null;
        }
        _tmp_24() {
            //# _tmp_24: yield_expr | star_expressions
            let mark, star_expressions, yield_expr;
            mark = this.mark();
            if ((yield_expr = this.yield_expr())) {
                return yield_expr;
            }
            this.reset(mark);
            if ((star_expressions = this.star_expressions())) {
                return star_expressions;
            }
            this.reset(mark);
            return null;
        }
        _loop0_26() {
            //# _loop0_26: ',' NAME
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.name())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_25() {
            //# _gather_25: NAME _loop0_26
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.name()) !== null && (seq = this._loop0_26()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _loop0_28() {
            //# _loop0_28: ',' NAME
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.name())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_27() {
            //# _gather_27: NAME _loop0_28
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.name()) !== null && (seq = this._loop0_28()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _tmp_29() {
            //# _tmp_29: ',' expression
            let mark, z;
            mark = this.mark();
            if ((this.expect(",")) && (z = this.expression())) {
                return z;
            }
            this.reset(mark);
            return null;
        }
        _tmp_30() {
            //# _tmp_30: ';' | NEWLINE
            let literal, mark, newline;
            mark = this.mark();
            if ((literal = this.expect(";"))) {
                return literal;
            }
            this.reset(mark);
            if ((newline = this.expect("NEWLINE"))) {
                return newline;
            }
            this.reset(mark);
            return null;
        }
        _loop0_31() {
            //# _loop0_31: ('.' | '...')
            let _tmp_137, children, mark;
            mark = this.mark();
            children = [];
            while ((_tmp_137 = this._tmp_137())) {
                children.push(_tmp_137);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop1_32() {
            //# _loop1_32: ('.' | '...')
            let _tmp_138, children, mark;
            mark = this.mark();
            children = [];
            while ((_tmp_138 = this._tmp_138())) {
                children.push(_tmp_138);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop0_34() {
            //# _loop0_34: ',' import_from_as_name
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.import_from_as_name())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_33() {
            //# _gather_33: import_from_as_name _loop0_34
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.import_from_as_name()) !== null && (seq = this._loop0_34()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _tmp_35() {
            //# _tmp_35: 'as' NAME
            let mark, z;
            mark = this.mark();
            if ((this.expect("as")) && (z = this.name())) {
                return z;
            }
            this.reset(mark);
            return null;
        }
        _loop0_37() {
            //# _loop0_37: ',' dotted_as_name
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.dotted_as_name())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_36() {
            //# _gather_36: dotted_as_name _loop0_37
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.dotted_as_name()) !== null && (seq = this._loop0_37()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _tmp_38() {
            //# _tmp_38: 'as' NAME
            let mark, z;
            mark = this.mark();
            if ((this.expect("as")) && (z = this.name())) {
                return z;
            }
            this.reset(mark);
            return null;
        }
        _loop0_40() {
            //# _loop0_40: ',' with_item
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.with_item())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_39() {
            //# _gather_39: with_item _loop0_40
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.with_item()) !== null && (seq = this._loop0_40()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _loop0_42() {
            //# _loop0_42: ',' with_item
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.with_item())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_41() {
            //# _gather_41: with_item _loop0_42
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.with_item()) !== null && (seq = this._loop0_42()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _loop0_44() {
            //# _loop0_44: ',' with_item
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.with_item())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_43() {
            //# _gather_43: with_item _loop0_44
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.with_item()) !== null && (seq = this._loop0_44()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _loop0_46() {
            //# _loop0_46: ',' with_item
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.with_item())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_45() {
            //# _gather_45: with_item _loop0_46
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.with_item()) !== null && (seq = this._loop0_46()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _tmp_47() {
            //# _tmp_47: ',' | ')' | ':'
            let literal, mark;
            mark = this.mark();
            if ((literal = this.expect(","))) {
                return literal;
            }
            this.reset(mark);
            if ((literal = this.expect(")"))) {
                return literal;
            }
            this.reset(mark);
            if ((literal = this.expect(":"))) {
                return literal;
            }
            this.reset(mark);
            return null;
        }
        _loop1_48() {
            //# _loop1_48: except_block
            let children, except_block, mark;
            mark = this.mark();
            children = [];
            while ((except_block = this.except_block())) {
                children.push(except_block);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _tmp_49() {
            //# _tmp_49: 'as' NAME
            let mark, z;
            mark = this.mark();
            if ((this.expect("as")) && (z = this.name())) {
                return z;
            }
            this.reset(mark);
            return null;
        }
        _tmp_50() {
            //# _tmp_50: 'from' expression
            let mark, z;
            mark = this.mark();
            if ((this.expect("from")) && (z = this.expression())) {
                return z;
            }
            this.reset(mark);
            return null;
        }
        _tmp_51() {
            //# _tmp_51: '->' expression
            let mark, z;
            mark = this.mark();
            if ((this.expect("->")) && (z = this.expression())) {
                return z;
            }
            this.reset(mark);
            return null;
        }
        _tmp_52() {
            //# _tmp_52: '->' expression
            let mark, z;
            mark = this.mark();
            if ((this.expect("->")) && (z = this.expression())) {
                return z;
            }
            this.reset(mark);
            return null;
        }
        _tmp_53() {
            //# _tmp_53: NEWLINE INDENT
            let indent, mark;
            mark = this.mark();
            if ((this.expect("NEWLINE")) && (indent = this.expect("INDENT"))) {
                return indent;
            }
            this.reset(mark);
            return null;
        }
        _loop0_54() {
            //# _loop0_54: param_no_default
            let children, mark, param_no_default;
            mark = this.mark();
            children = [];
            while ((param_no_default = this.param_no_default())) {
                children.push(param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop0_55() {
            //# _loop0_55: param_with_default
            let children, mark, param_with_default;
            mark = this.mark();
            children = [];
            while ((param_with_default = this.param_with_default())) {
                children.push(param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop0_56() {
            //# _loop0_56: param_with_default
            let children, mark, param_with_default;
            mark = this.mark();
            children = [];
            while ((param_with_default = this.param_with_default())) {
                children.push(param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop1_57() {
            //# _loop1_57: param_no_default
            let children, mark, param_no_default;
            mark = this.mark();
            children = [];
            while ((param_no_default = this.param_no_default())) {
                children.push(param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop0_58() {
            //# _loop0_58: param_with_default
            let children, mark, param_with_default;
            mark = this.mark();
            children = [];
            while ((param_with_default = this.param_with_default())) {
                children.push(param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop1_59() {
            //# _loop1_59: param_with_default
            let children, mark, param_with_default;
            mark = this.mark();
            children = [];
            while ((param_with_default = this.param_with_default())) {
                children.push(param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop1_60() {
            //# _loop1_60: param_no_default
            let children, mark, param_no_default;
            mark = this.mark();
            children = [];
            while ((param_no_default = this.param_no_default())) {
                children.push(param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop1_61() {
            //# _loop1_61: param_no_default
            let children, mark, param_no_default;
            mark = this.mark();
            children = [];
            while ((param_no_default = this.param_no_default())) {
                children.push(param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop0_62() {
            //# _loop0_62: param_no_default
            let children, mark, param_no_default;
            mark = this.mark();
            children = [];
            while ((param_no_default = this.param_no_default())) {
                children.push(param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop1_63() {
            //# _loop1_63: param_with_default
            let children, mark, param_with_default;
            mark = this.mark();
            children = [];
            while ((param_with_default = this.param_with_default())) {
                children.push(param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop0_64() {
            //# _loop0_64: param_no_default
            let children, mark, param_no_default;
            mark = this.mark();
            children = [];
            while ((param_no_default = this.param_no_default())) {
                children.push(param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop1_65() {
            //# _loop1_65: param_with_default
            let children, mark, param_with_default;
            mark = this.mark();
            children = [];
            while ((param_with_default = this.param_with_default())) {
                children.push(param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop0_66() {
            //# _loop0_66: param_maybe_default
            let children, mark, param_maybe_default;
            mark = this.mark();
            children = [];
            while ((param_maybe_default = this.param_maybe_default())) {
                children.push(param_maybe_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop1_67() {
            //# _loop1_67: param_maybe_default
            let children, mark, param_maybe_default;
            mark = this.mark();
            children = [];
            while ((param_maybe_default = this.param_maybe_default())) {
                children.push(param_maybe_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop1_68() {
            //# _loop1_68: ('@' named_expression NEWLINE)
            let _tmp_139, children, mark;
            mark = this.mark();
            children = [];
            while ((_tmp_139 = this._tmp_139())) {
                children.push(_tmp_139);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _tmp_69() {
            //# _tmp_69: '(' arguments? ')'
            let mark, z;
            mark = this.mark();
            if ((this.expect("(")) && (z = this.arguments() || 1) && (this.expect(")"))) {
                return z;
            }
            this.reset(mark);
            return null;
        }
        _loop1_70() {
            //# _loop1_70: (',' star_expression)
            let _tmp_140, children, mark;
            mark = this.mark();
            children = [];
            while ((_tmp_140 = this._tmp_140())) {
                children.push(_tmp_140);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop0_72() {
            //# _loop0_72: ',' star_named_expression
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.star_named_expression())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_71() {
            //# _gather_71: star_named_expression _loop0_72
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.star_named_expression()) !== null && (seq = this._loop0_72()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _loop1_73() {
            //# _loop1_73: (',' expression)
            let _tmp_141, children, mark;
            mark = this.mark();
            children = [];
            while ((_tmp_141 = this._tmp_141())) {
                children.push(_tmp_141);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop0_74() {
            //# _loop0_74: lambda_param_no_default
            let children, lambda_param_no_default, mark;
            mark = this.mark();
            children = [];
            while ((lambda_param_no_default = this.lambda_param_no_default())) {
                children.push(lambda_param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop0_75() {
            //# _loop0_75: lambda_param_with_default
            let children, lambda_param_with_default, mark;
            mark = this.mark();
            children = [];
            while ((lambda_param_with_default = this.lambda_param_with_default())) {
                children.push(lambda_param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop0_76() {
            //# _loop0_76: lambda_param_with_default
            let children, lambda_param_with_default, mark;
            mark = this.mark();
            children = [];
            while ((lambda_param_with_default = this.lambda_param_with_default())) {
                children.push(lambda_param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop1_77() {
            //# _loop1_77: lambda_param_no_default
            let children, lambda_param_no_default, mark;
            mark = this.mark();
            children = [];
            while ((lambda_param_no_default = this.lambda_param_no_default())) {
                children.push(lambda_param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop0_78() {
            //# _loop0_78: lambda_param_with_default
            let children, lambda_param_with_default, mark;
            mark = this.mark();
            children = [];
            while ((lambda_param_with_default = this.lambda_param_with_default())) {
                children.push(lambda_param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop1_79() {
            //# _loop1_79: lambda_param_with_default
            let children, lambda_param_with_default, mark;
            mark = this.mark();
            children = [];
            while ((lambda_param_with_default = this.lambda_param_with_default())) {
                children.push(lambda_param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop1_80() {
            //# _loop1_80: lambda_param_no_default
            let children, lambda_param_no_default, mark;
            mark = this.mark();
            children = [];
            while ((lambda_param_no_default = this.lambda_param_no_default())) {
                children.push(lambda_param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop1_81() {
            //# _loop1_81: lambda_param_no_default
            let children, lambda_param_no_default, mark;
            mark = this.mark();
            children = [];
            while ((lambda_param_no_default = this.lambda_param_no_default())) {
                children.push(lambda_param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop0_82() {
            //# _loop0_82: lambda_param_no_default
            let children, lambda_param_no_default, mark;
            mark = this.mark();
            children = [];
            while ((lambda_param_no_default = this.lambda_param_no_default())) {
                children.push(lambda_param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop1_83() {
            //# _loop1_83: lambda_param_with_default
            let children, lambda_param_with_default, mark;
            mark = this.mark();
            children = [];
            while ((lambda_param_with_default = this.lambda_param_with_default())) {
                children.push(lambda_param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop0_84() {
            //# _loop0_84: lambda_param_no_default
            let children, lambda_param_no_default, mark;
            mark = this.mark();
            children = [];
            while ((lambda_param_no_default = this.lambda_param_no_default())) {
                children.push(lambda_param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop1_85() {
            //# _loop1_85: lambda_param_with_default
            let children, lambda_param_with_default, mark;
            mark = this.mark();
            children = [];
            while ((lambda_param_with_default = this.lambda_param_with_default())) {
                children.push(lambda_param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop0_86() {
            //# _loop0_86: lambda_param_maybe_default
            let children, lambda_param_maybe_default, mark;
            mark = this.mark();
            children = [];
            while ((lambda_param_maybe_default = this.lambda_param_maybe_default())) {
                children.push(lambda_param_maybe_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop1_87() {
            //# _loop1_87: lambda_param_maybe_default
            let children, lambda_param_maybe_default, mark;
            mark = this.mark();
            children = [];
            while ((lambda_param_maybe_default = this.lambda_param_maybe_default())) {
                children.push(lambda_param_maybe_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop1_88() {
            //# _loop1_88: ('or' conjunction)
            let _tmp_142, children, mark;
            mark = this.mark();
            children = [];
            while ((_tmp_142 = this._tmp_142())) {
                children.push(_tmp_142);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop1_89() {
            //# _loop1_89: ('and' inversion)
            let _tmp_143, children, mark;
            mark = this.mark();
            children = [];
            while ((_tmp_143 = this._tmp_143())) {
                children.push(_tmp_143);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop1_90() {
            //# _loop1_90: compare_op_bitwise_or_pair
            let children, compare_op_bitwise_or_pair, mark;
            mark = this.mark();
            children = [];
            while ((compare_op_bitwise_or_pair = this.compare_op_bitwise_or_pair())) {
                children.push(compare_op_bitwise_or_pair);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop0_92() {
            //# _loop0_92: ',' slice
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.slice())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_91() {
            //# _gather_91: slice _loop0_92
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.slice()) !== null && (seq = this._loop0_92()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _tmp_93() {
            //# _tmp_93: ':' expression?
            let d, mark;
            mark = this.mark();
            if ((this.expect(":")) && (d = this.expression() || 1)) {
                return d;
            }
            this.reset(mark);
            return null;
        }
        _tmp_94() {
            //# _tmp_94: tuple | group | genexp
            let genexp, group, mark, tuple;
            mark = this.mark();
            if ((tuple = this.tuple())) {
                return tuple;
            }
            this.reset(mark);
            if ((group = this.group())) {
                return group;
            }
            this.reset(mark);
            if ((genexp = this.genexp())) {
                return genexp;
            }
            this.reset(mark);
            return null;
        }
        _tmp_95() {
            //# _tmp_95: list | listcomp
            let list, listcomp, mark;
            mark = this.mark();
            if ((list = this.list())) {
                return list;
            }
            this.reset(mark);
            if ((listcomp = this.listcomp())) {
                return listcomp;
            }
            this.reset(mark);
            return null;
        }
        _tmp_96() {
            //# _tmp_96: dict | set | dictcomp | setcomp
            let dict, dictcomp, mark, set, setcomp;
            mark = this.mark();
            if ((dict = this.dict())) {
                return dict;
            }
            this.reset(mark);
            if ((set = this.set())) {
                return set;
            }
            this.reset(mark);
            if ((dictcomp = this.dictcomp())) {
                return dictcomp;
            }
            this.reset(mark);
            if ((setcomp = this.setcomp())) {
                return setcomp;
            }
            this.reset(mark);
            return null;
        }
        _loop1_97() {
            //# _loop1_97: STRING
            let children, mark, string;
            mark = this.mark();
            children = [];
            while ((string = this.string())) {
                children.push(string);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _tmp_98() {
            //# _tmp_98: star_named_expression ',' star_named_expressions?
            let mark, y, z;
            mark = this.mark();
            if ((y = this.star_named_expression()) && (this.expect(",")) && (z = this.star_named_expressions() || 1)) {
                return pegen.seq_insert_in_front(y, z);
            }
            this.reset(mark);
            return null;
        }
        _tmp_99() {
            //# _tmp_99: yield_expr | named_expression
            let mark, named_expression, yield_expr;
            mark = this.mark();
            if ((yield_expr = this.yield_expr())) {
                return yield_expr;
            }
            this.reset(mark);
            if ((named_expression = this.named_expression())) {
                return named_expression;
            }
            this.reset(mark);
            return null;
        }
        _loop0_101() {
            //# _loop0_101: ',' double_starred_kvpair
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.double_starred_kvpair())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_100() {
            //# _gather_100: double_starred_kvpair _loop0_101
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.double_starred_kvpair()) !== null && (seq = this._loop0_101()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _loop1_102() {
            //# _loop1_102: for_if_clause
            let children, for_if_clause, mark;
            mark = this.mark();
            children = [];
            while ((for_if_clause = this.for_if_clause())) {
                children.push(for_if_clause);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop0_103() {
            //# _loop0_103: ('if' disjunction)
            let _tmp_144, children, mark;
            mark = this.mark();
            children = [];
            while ((_tmp_144 = this._tmp_144())) {
                children.push(_tmp_144);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop0_104() {
            //# _loop0_104: ('if' disjunction)
            let _tmp_145, children, mark;
            mark = this.mark();
            children = [];
            while ((_tmp_145 = this._tmp_145())) {
                children.push(_tmp_145);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop0_106() {
            //# _loop0_106: ',' (starred_expression | named_expression !'=')
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this._tmp_146())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_105() {
            //# _gather_105: (starred_expression | named_expression !'=') _loop0_106
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this._tmp_146()) !== null && (seq = this._loop0_106()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _tmp_107() {
            //# _tmp_107: ',' kwargs
            let k, mark;
            mark = this.mark();
            if ((this.expect(",")) && (k = this.kwargs())) {
                return k;
            }
            this.reset(mark);
            return null;
        }
        _loop0_109() {
            //# _loop0_109: ',' kwarg_or_starred
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.kwarg_or_starred())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_108() {
            //# _gather_108: kwarg_or_starred _loop0_109
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.kwarg_or_starred()) !== null && (seq = this._loop0_109()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _loop0_111() {
            //# _loop0_111: ',' kwarg_or_double_starred
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.kwarg_or_double_starred())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_110() {
            //# _gather_110: kwarg_or_double_starred _loop0_111
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.kwarg_or_double_starred()) !== null && (seq = this._loop0_111()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _loop0_113() {
            //# _loop0_113: ',' kwarg_or_starred
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.kwarg_or_starred())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_112() {
            //# _gather_112: kwarg_or_starred _loop0_113
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.kwarg_or_starred()) !== null && (seq = this._loop0_113()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _loop0_115() {
            //# _loop0_115: ',' kwarg_or_double_starred
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.kwarg_or_double_starred())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_114() {
            //# _gather_114: kwarg_or_double_starred _loop0_115
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.kwarg_or_double_starred()) !== null && (seq = this._loop0_115()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _loop0_116() {
            //# _loop0_116: (',' star_target)
            let _tmp_147, children, mark;
            mark = this.mark();
            children = [];
            while ((_tmp_147 = this._tmp_147())) {
                children.push(_tmp_147);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop0_118() {
            //# _loop0_118: ',' star_target
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.star_target())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_117() {
            //# _gather_117: star_target _loop0_118
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.star_target()) !== null && (seq = this._loop0_118()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _tmp_119() {
            //# _tmp_119: !'*' star_target
            let mark, star_target;
            mark = this.mark();
            if (this.negative_lookahead(this.expect, "*") && (star_target = this.star_target())) {
                return star_target;
            }
            this.reset(mark);
            return null;
        }
        _loop0_121() {
            //# _loop0_121: ',' del_target
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.del_target())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_120() {
            //# _gather_120: del_target _loop0_121
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.del_target()) !== null && (seq = this._loop0_121()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _loop0_123() {
            //# _loop0_123: ',' target
            let children, elem, mark;
            mark = this.mark();
            children = [];
            while ((this.expect(",")) && (elem = this.target())) {
                children.push(elem);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _gather_122() {
            //# _gather_122: target _loop0_123
            let elem, mark, seq;
            mark = this.mark();
            if ((elem = this.target()) !== null && (seq = this._loop0_123()) !== null) {
                return [elem, ...seq];
            }
            this.reset(mark);
            return null;
        }
        _tmp_124() {
            //# _tmp_124: args | expression for_if_clauses
            let args, for_if_clauses, mark;
            mark = this.mark();
            if ((args = this.args())) {
                return args;
            }
            this.reset(mark);
            if ((this.expression()) && (for_if_clauses = this.for_if_clauses())) {
                return for_if_clauses;
            }
            this.reset(mark);
            return null;
        }
        _loop0_125() {
            //# _loop0_125: star_named_expressions
            let children, mark, star_named_expressions;
            mark = this.mark();
            children = [];
            while ((star_named_expressions = this.star_named_expressions())) {
                children.push(star_named_expressions);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop0_126() {
            //# _loop0_126: (star_targets '=')
            let _tmp_148, children, mark;
            mark = this.mark();
            children = [];
            while ((_tmp_148 = this._tmp_148())) {
                children.push(_tmp_148);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _loop0_127() {
            //# _loop0_127: (star_targets '=')
            let _tmp_149, children, mark;
            mark = this.mark();
            children = [];
            while ((_tmp_149 = this._tmp_149())) {
                children.push(_tmp_149);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _tmp_128() {
            //# _tmp_128: yield_expr | star_expressions
            let mark, star_expressions, yield_expr;
            mark = this.mark();
            if ((yield_expr = this.yield_expr())) {
                return yield_expr;
            }
            this.reset(mark);
            if ((star_expressions = this.star_expressions())) {
                return star_expressions;
            }
            this.reset(mark);
            return null;
        }
        _tmp_129() {
            //# _tmp_129: '[' | '(' | '{'
            let literal, mark;
            mark = this.mark();
            if ((literal = this.expect("["))) {
                return literal;
            }
            this.reset(mark);
            if ((literal = this.expect("("))) {
                return literal;
            }
            this.reset(mark);
            if ((literal = this.expect("{"))) {
                return literal;
            }
            this.reset(mark);
            return null;
        }
        _loop0_130() {
            //# _loop0_130: param_no_default
            let children, mark, param_no_default;
            mark = this.mark();
            children = [];
            while ((param_no_default = this.param_no_default())) {
                children.push(param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _tmp_131() {
            //# _tmp_131: slash_with_default | param_with_default+
            let _loop1_150, mark, slash_with_default;
            mark = this.mark();
            if ((slash_with_default = this.slash_with_default())) {
                return slash_with_default;
            }
            this.reset(mark);
            if ((_loop1_150 = this._loop1_150())) {
                return _loop1_150;
            }
            this.reset(mark);
            return null;
        }
        _loop0_132() {
            //# _loop0_132: lambda_param_no_default
            let children, lambda_param_no_default, mark;
            mark = this.mark();
            children = [];
            while ((lambda_param_no_default = this.lambda_param_no_default())) {
                children.push(lambda_param_no_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children;
        }
        _tmp_133() {
            //# _tmp_133: lambda_slash_with_default | lambda_param_with_default+
            let _loop1_151, lambda_slash_with_default, mark;
            mark = this.mark();
            if ((lambda_slash_with_default = this.lambda_slash_with_default())) {
                return lambda_slash_with_default;
            }
            this.reset(mark);
            if ((_loop1_151 = this._loop1_151())) {
                return _loop1_151;
            }
            this.reset(mark);
            return null;
        }
        _tmp_134() {
            //# _tmp_134: ')' | ',' (')' | '**')
            let _tmp_152, literal, mark;
            mark = this.mark();
            if ((literal = this.expect(")"))) {
                return literal;
            }
            this.reset(mark);
            if ((literal = this.expect(",")) && (_tmp_152 = this._tmp_152())) {
                return _tmp_152;
            }
            this.reset(mark);
            return null;
        }
        _tmp_135() {
            //# _tmp_135: ':' | ',' (':' | '**')
            let _tmp_153, literal, mark;
            mark = this.mark();
            if ((literal = this.expect(":"))) {
                return literal;
            }
            this.reset(mark);
            if ((literal = this.expect(",")) && (_tmp_153 = this._tmp_153())) {
                return _tmp_153;
            }
            this.reset(mark);
            return null;
        }
        _tmp_136() {
            //# _tmp_136: star_targets '='
            let mark, z;
            mark = this.mark();
            if ((z = this.star_targets()) && (this.expect("="))) {
                return z;
            }
            this.reset(mark);
            return null;
        }
        _tmp_137() {
            //# _tmp_137: '.' | '...'
            let literal, mark;
            mark = this.mark();
            if ((literal = this.expect("."))) {
                return literal;
            }
            this.reset(mark);
            if ((literal = this.expect("..."))) {
                return literal;
            }
            this.reset(mark);
            return null;
        }
        _tmp_138() {
            //# _tmp_138: '.' | '...'
            let literal, mark;
            mark = this.mark();
            if ((literal = this.expect("."))) {
                return literal;
            }
            this.reset(mark);
            if ((literal = this.expect("..."))) {
                return literal;
            }
            this.reset(mark);
            return null;
        }
        _tmp_139() {
            //# _tmp_139: '@' named_expression NEWLINE
            let f, mark;
            mark = this.mark();
            if ((this.expect("@")) && (f = this.named_expression()) && (this.expect("NEWLINE"))) {
                return f;
            }
            this.reset(mark);
            return null;
        }
        _tmp_140() {
            //# _tmp_140: ',' star_expression
            let c, mark;
            mark = this.mark();
            if ((this.expect(",")) && (c = this.star_expression())) {
                return c;
            }
            this.reset(mark);
            return null;
        }
        _tmp_141() {
            //# _tmp_141: ',' expression
            let c, mark;
            mark = this.mark();
            if ((this.expect(",")) && (c = this.expression())) {
                return c;
            }
            this.reset(mark);
            return null;
        }
        _tmp_142() {
            //# _tmp_142: 'or' conjunction
            let c, mark;
            mark = this.mark();
            if ((this.expect("or")) && (c = this.conjunction())) {
                return c;
            }
            this.reset(mark);
            return null;
        }
        _tmp_143() {
            //# _tmp_143: 'and' inversion
            let c, mark;
            mark = this.mark();
            if ((this.expect("and")) && (c = this.inversion())) {
                return c;
            }
            this.reset(mark);
            return null;
        }
        _tmp_144() {
            //# _tmp_144: 'if' disjunction
            let mark, z;
            mark = this.mark();
            if ((this.expect("if")) && (z = this.disjunction())) {
                return z;
            }
            this.reset(mark);
            return null;
        }
        _tmp_145() {
            //# _tmp_145: 'if' disjunction
            let mark, z;
            mark = this.mark();
            if ((this.expect("if")) && (z = this.disjunction())) {
                return z;
            }
            this.reset(mark);
            return null;
        }
        _tmp_146() {
            //# _tmp_146: starred_expression | named_expression !'='
            let mark, named_expression, starred_expression;
            mark = this.mark();
            if ((starred_expression = this.starred_expression())) {
                return starred_expression;
            }
            this.reset(mark);
            if ((named_expression = this.named_expression()) && this.negative_lookahead(this.expect, "=")) {
                return named_expression;
            }
            this.reset(mark);
            return null;
        }
        _tmp_147() {
            //# _tmp_147: ',' star_target
            let c, mark;
            mark = this.mark();
            if ((this.expect(",")) && (c = this.star_target())) {
                return c;
            }
            this.reset(mark);
            return null;
        }
        _tmp_148() {
            //# _tmp_148: star_targets '='
            let literal, mark;
            mark = this.mark();
            if ((this.star_targets()) && (literal = this.expect("="))) {
                return literal;
            }
            this.reset(mark);
            return null;
        }
        _tmp_149() {
            //# _tmp_149: star_targets '='
            let literal, mark;
            mark = this.mark();
            if ((this.star_targets()) && (literal = this.expect("="))) {
                return literal;
            }
            this.reset(mark);
            return null;
        }
        _loop1_150() {
            //# _loop1_150: param_with_default
            let children, mark, param_with_default;
            mark = this.mark();
            children = [];
            while ((param_with_default = this.param_with_default())) {
                children.push(param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _loop1_151() {
            //# _loop1_151: lambda_param_with_default
            let children, lambda_param_with_default, mark;
            mark = this.mark();
            children = [];
            while ((lambda_param_with_default = this.lambda_param_with_default())) {
                children.push(lambda_param_with_default);
                mark = this.mark();
            }
            this.reset(mark);
            return children.length ? children : null;
        }
        _tmp_152() {
            //# _tmp_152: ')' | '**'
            let literal, mark;
            mark = this.mark();
            if ((literal = this.expect(")"))) {
                return literal;
            }
            this.reset(mark);
            if ((literal = this.expect("**"))) {
                return literal;
            }
            this.reset(mark);
            return null;
        }
        _tmp_153() {
            //# _tmp_153: ':' | '**'
            let literal, mark;
            mark = this.mark();
            if ((literal = this.expect(":"))) {
                return literal;
            }
            this.reset(mark);
            if ((literal = this.expect("**"))) {
                return literal;
            }
            this.reset(mark);
            return null;
        }
    }
    __decorate([
        memoize
    ], GeneratedParser.prototype, "file", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "interactive", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "eval", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "func_type", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "fstring", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "type_expressions", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "statements", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "statement", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "statement_newline", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "simple_stmts", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "simple_stmt", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "compound_stmt", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "assignment", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "augassign", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "global_stmt", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "nonlocal_stmt", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "yield_stmt", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "assert_stmt", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "del_stmt", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "import_stmt", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "import_name", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "import_from", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "import_from_targets", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "import_from_as_names", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "import_from_as_name", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "dotted_as_names", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "dotted_as_name", null);
    __decorate([
        memoize_left_rec
    ], GeneratedParser.prototype, "dotted_name", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "if_stmt", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "elif_stmt", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "else_block", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "while_stmt", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "for_stmt", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "with_stmt", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "with_item", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "try_stmt", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "except_block", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "finally_block", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "return_stmt", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "raise_stmt", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "function_def", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "function_def_raw", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "func_type_comment", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "params", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "parameters", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "slash_no_default", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "slash_with_default", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "star_etc", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "kwds", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "param_no_default", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "param_with_default", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "param_maybe_default", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "param", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "annotation", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "default", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "decorators", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "class_def", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "class_def_raw", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "block", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "star_expressions", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "star_expression", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "star_named_expressions", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "star_named_expression", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "named_expression", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "annotated_rhs", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "expressions", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "expression", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "lambdef", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "lambda_params", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "lambda_parameters", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "lambda_slash_no_default", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "lambda_slash_with_default", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "lambda_star_etc", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "lambda_kwds", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "lambda_param_no_default", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "lambda_param_with_default", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "lambda_param_maybe_default", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "lambda_param", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "disjunction", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "conjunction", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "inversion", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "comparison", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "compare_op_bitwise_or_pair", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "eq_bitwise_or", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "noteq_bitwise_or", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "lte_bitwise_or", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "lt_bitwise_or", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "gte_bitwise_or", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "gt_bitwise_or", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "notin_bitwise_or", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "in_bitwise_or", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "isnot_bitwise_or", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "is_bitwise_or", null);
    __decorate([
        memoize_left_rec
    ], GeneratedParser.prototype, "bitwise_or", null);
    __decorate([
        memoize_left_rec
    ], GeneratedParser.prototype, "bitwise_xor", null);
    __decorate([
        memoize_left_rec
    ], GeneratedParser.prototype, "bitwise_and", null);
    __decorate([
        memoize_left_rec
    ], GeneratedParser.prototype, "shift_expr", null);
    __decorate([
        memoize_left_rec
    ], GeneratedParser.prototype, "sum", null);
    __decorate([
        memoize_left_rec
    ], GeneratedParser.prototype, "term", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "factor", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "power", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "await_primary", null);
    __decorate([
        memoize_left_rec
    ], GeneratedParser.prototype, "primary", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "slices", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "slice", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "atom", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "strings", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "list", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "listcomp", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "tuple", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "group", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "genexp", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "set", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "setcomp", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "dict", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "dictcomp", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "double_starred_kvpairs", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "double_starred_kvpair", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "kvpair", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "for_if_clauses", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "for_if_clause", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "yield_expr", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "arguments", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "args", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "kwargs", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "starred_expression", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "kwarg_or_starred", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "kwarg_or_double_starred", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "star_targets", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "star_targets_seq", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "star_target", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "star_atom", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "single_target", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "single_subscript_attribute_target", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "del_targets", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "del_target", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "del_t_atom", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "targets", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "target", null);
    __decorate([
        memoize_left_rec
    ], GeneratedParser.prototype, "t_primary", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "t_lookahead", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "t_atom", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_arguments", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_kwarg", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_named_expression", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_assignment", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_ann_assign_target", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_del_stmt", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_block", null);
    __decorate([
        logger
    ], GeneratedParser.prototype, "invalid_primary", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_comprehension", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_dict_comprehension", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_parameters", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_lambda_parameters", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_star_etc", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_lambda_star_etc", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_double_type_comments", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_with_item", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_for_target", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_group", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "invalid_import_from_targets", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_1", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_2", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_4", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_3", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_6", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_5", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_8", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_7", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_10", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_9", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_11", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_13", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_12", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_14", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_15", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_16", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_17", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_18", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_19", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_20", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_21", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_22", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_23", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_24", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_26", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_25", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_28", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_27", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_29", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_30", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_31", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_32", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_34", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_33", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_35", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_37", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_36", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_38", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_40", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_39", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_42", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_41", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_44", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_43", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_46", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_45", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_47", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_48", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_49", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_50", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_51", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_52", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_53", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_54", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_55", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_56", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_57", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_58", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_59", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_60", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_61", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_62", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_63", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_64", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_65", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_66", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_67", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_68", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_69", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_70", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_72", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_71", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_73", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_74", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_75", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_76", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_77", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_78", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_79", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_80", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_81", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_82", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_83", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_84", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_85", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_86", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_87", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_88", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_89", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_90", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_92", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_91", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_93", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_94", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_95", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_96", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_97", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_98", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_99", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_101", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_100", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_102", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_103", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_104", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_106", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_105", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_107", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_109", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_108", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_111", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_110", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_113", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_112", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_115", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_114", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_116", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_118", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_117", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_119", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_121", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_120", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_123", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_gather_122", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_124", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_125", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_126", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_127", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_128", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_129", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_130", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_131", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop0_132", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_133", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_134", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_135", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_136", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_137", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_138", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_139", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_140", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_141", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_142", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_143", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_144", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_145", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_146", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_147", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_148", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_149", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_150", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_loop1_151", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_152", null);
    __decorate([
        memoize
    ], GeneratedParser.prototype, "_tmp_153", null);

    const { Lu, Ll, Lt: Lt$1, Lm, Lo, Nl, Mn, Mc, Nd, Pc } = Unicode;
    const the_underscore = "_";
    const Other_ID_Start = '\\u1885-\\u1886\\u2118\\u212E\\u309B-\\u309C';
    const Other_ID_Continue = '\\u00B7\\u0387\\u1369-\\u1371\\u19DA';
    const id_start = Lu + Ll + Lt$1 + Lm + Lo + Nl + the_underscore + Other_ID_Start;
    const id_continue = id_start + Mn + Mc + Nd + Pc + Other_ID_Continue;
    const IS_IDENTIFIER_REGEX = new RegExp('^([' + id_start + '])+([' + id_continue + '])*$');
    String.prototype.isIdentifier = function () {
        return IS_IDENTIFIER_REGEX.test(this.normalize('NFKC'));
    };
    const IS_SPACE = /^\s+$/;
    String.prototype.isSpace = function () {
        return IS_SPACE.test(this);
    };

    var _String = /*#__PURE__*/Object.freeze({
        __proto__: null
    });

    function ___buildNativeClass(name) {
        console.log('native class called');
        return function (constructor) {
            debugger;
            console.log('native class done');
            return constructor;
        };
    }
    function method(flags, docstring, textsignature) {
        console.log('method called');
        return function (target, propertyKey, descriptor) {
            debugger;
            const meth = descriptor.value;
            meth.flags = flags;
            meth.docstring = docstring;
            meth.textsignature = textsignature;
            console.log('method done');
        };
    }
    function classmethod(flags, docstring, textsignature) {
        console.log('method called');
        return function (target, propertyKey, descriptor) {
            debugger;
            const meth = descriptor.value;
            meth.flags = flags;
            meth.docstring = docstring;
            meth.textsignature = textsignature;
            console.log('method done');
        };
    }
    function prop(target, key) {
        target[key] = 1;
    }
    function getset(...decargs) {
        debugger;
        return function (...args) {
            debugger;
        };
    }
    let ___pyNoneType = class ___pyNoneType {
        constructor() {
            // return pyNone;
        }
        valueOf() {
            return null;
        }
        foo() {
            return 'bar';
        }
        bar() {
        }
        get __class__() {
            this.name();
            return 'foo';
        }
        set __class__(v) {
        }
        name() {
            console.log('foo');
        }
    };
    __decorate([
        method({ NoArgs: true }, 'this is a docstring foo', 'bar')
    ], ___pyNoneType.prototype, "foo", null);
    __decorate([
        classmethod({ NoArgs: true }, 'this is a docstring foo', 'bar')
    ], ___pyNoneType.prototype, "bar", null);
    __decorate([
        getset("some doc string")
    ], ___pyNoneType.prototype, "__class__", null);
    __decorate([
        prop
    ], ___pyNoneType.prototype, "eggs", void 0);
    ___pyNoneType = __decorate([
        ___buildNativeClass()
    ], ___pyNoneType);
    const ___pyNone = Object.create(___pyNoneType.prototype);

    exports.GeneratedParser = GeneratedParser;
    exports.Tokenizer = Tokenizer;
    exports.___pyNone = ___pyNone;
    exports.foo = _String;
    exports.readline = readline;
    exports.tokenize = tokenize;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

}({}));
//# sourceMappingURL=bundle.js.map
